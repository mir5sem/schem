# 12. Методы и инструменты верификации Часть 2. Стандарты.
## Прошлая лекция
## Структура тестового окружения в UVM
Лекция описывает структуру тестового окружения в UVM, которая является стандартизированным и модульным подходом к организации верификации. Эта структура построена на базе *транзакционной модели* и включает в себя несколько ключевых компонентов:

**1. Test (Тест):**

* Находится на самом верхнем уровне иерархии.
* Задает параметры и конфигурацию для всего тестового окружения.
* Запускает выполнение теста и контролирует его завершение.
* Может содержать несколько тестовых сценариев (test cases).

**2. Environment (Окружение):**

* Контейнер, объединяющий все компоненты верификации.
* Может содержать в себе другие окружения, создавая иерархическую структуру.
* Обеспечивает взаимодействие между компонентами.

**3. Sequencer (Секвенсор):**

* Генерирует последовательности транзакций (sequences) и отправляет их в драйвер.
* Управляет порядком генерации транзакций.

**4. Driver (Драйвер):**

* Получает транзакции от секвенсора.
* Преобразует транзакции в сигналы на уровне интерфейса устройства (DUT - Device Under Test).
* Подает сигналы на DUT.

**5. Monitor (Монитор):**

* Наблюдает за сигналами на интерфейсе DUT.
* Преобразует сигналы в транзакции.
* Отправляет транзакции в scoreboard и другие компоненты для анализа.

**6. Scoreboard (Счетчик):**

* Получает транзакции от монитора и модели устройства (или другого источника ожидаемых значений).
* Сравнивает полученные транзакции с ожидаемыми.
* Выдает сообщения об ошибках при несовпадении.

**7. Agent (Агент):**

* Объединяет driver, monitor и sequencer для одного интерфейса DUT.
* Упрощает взаимодействие между этими компонентами.
* Может быть активным (содержит driver и sequencer) или пассивным (только monitor).

**8. Sequence Item (Элемент последовательности):**

* Представляет собой одну транзакцию.
* Содержит данные, которыми обмениваются компоненты.

**9. Sequence (Последовательность):**

* Определяет порядок генерации транзакций (sequence items).

**Транзакционная модель:**

* Основа взаимодействия между компонентами UVM.
* Транзакции – это объекты, содержащие информацию о данных, которыми обмениваются компоненты.
* Драйвер преобразует транзакции в сигналы, а монитор – сигналы в транзакции.

**Уровни абстракции:**

* UVM использует два уровня абстракции: транзакционный и сигнальный.
* Транзакционный уровень используется для взаимодействия между компонентами UVM.
* Сигнальный уровень используется для взаимодействия с DUT.

**Преимущества данной структуры:**

* **Модульность:** Компоненты UVM независимы друг от друга, что упрощает их разработку, отладку и повторное использование.
* **Повторное использование:** Компоненты UVM могут быть легко использованы в разных тестовых окружениях.
* **Масштабируемость:**  UVM подходит для верификации как небольших, так и очень крупных проектов.
* **Стандартизация:**  Стандартизированная структура упрощает взаимодействие между разработчиками и обеспечивает совместимость между различными инструментами верификации.


Эта структурированная модель позволяет создавать гибкие и мощные тестовые окружения, которые легко адаптировать под различные задачи верификации.

### Компоненты UVM
Лекция описывает ключевые компоненты UVM, каждый из которых играет определенную роль в процессе верификации:

**1. Environment (Окружение):**

* **Роль:**  Environment выступает в качестве контейнера, объединяющего все остальные компоненты UVM. Он обеспечивает инфраструктуру для взаимодействия между компонентами и DUT (Device Under Test).  Environment также отвечает за настройку и конфигурацию тестового окружения.
* **Взаимодействие:** Environment содержит в себе один или несколько агентов (agents), которые, в свою очередь, содержат драйверы, мониторы и секвенсоры.  Он также может содержать другие окружения, создавая иерархическую структуру.
* **Аналогия:**  Представьте себе Environment как материнскую плату компьютера, которая объединяет все остальные компоненты (процессор, память, видеокарту и т.д.) и обеспечивает их взаимодействие.

**2. Sequencer (Секвенсор):**

* **Роль:** Sequencer отвечает за генерацию последовательностей транзакций (sequences) и отправку их в драйвер (driver). Он управляет порядком генерации транзакций и обеспечивает синхронизацию между драйвером и другими компонентами тестового окружения.
* **Взаимодействие:** Sequencer взаимодействует с драйвером через порт, называемый sequencer-driver interface.  Он получает запросы на транзакции от драйвера и отправляет ему транзакции в соответствии с заданной последовательностью.
* **Аналогия:**  Sequencer можно сравнить с дирижером оркестра, который управляет исполнением музыкального произведения, задавая темп и порядок вступления различных инструментов.

**3. Driver (Драйвер):**

* **Роль:** Driver получает транзакции от sequencer и преобразует их в физические сигналы, которые подаются на DUT.  Он отвечает за стимуляцию DUT и эмуляцию внешнего окружения.
* **Взаимодействие:** Driver взаимодействует с DUT через интерфейс (interface).  Он также взаимодействует с секвенсором через sequencer-driver interface.
* **Аналогия:**  Driver можно сравнить с водителем автомобиля, который получает команды от навигатора (sequencer) и управляет автомобилем (DUT) в соответствии с этими командами.

**4. Monitor (Монитор):**

* **Роль:** Monitor пассивно наблюдает за сигналами на интерфейсе DUT и преобразует их обратно в транзакции.  Он не влияет на работу DUT, а только собирает информацию о его поведении.
* **Взаимодействие:** Monitor взаимодействует с DUT через интерфейс (interface).  Он отправляет собранные транзакции в scoreboard и другие компоненты для анализа.
* **Аналогия:**  Monitor можно сравнить с видеорегистратором, который записывает все происходящее на дороге, не вмешиваясь в управление автомобилем.

**5. Scoreboard (Счетчик):**

* **Роль:** Scoreboard получает транзакции от монитора и сравнивает их с ожидаемыми значениями.  Он отвечает за проверку корректности работы DUT.
* **Взаимодействие:** Scoreboard взаимодействует с монитором и, возможно, с другими компонентами, которые генерируют ожидаемые значения (например, модель устройства).
* **Аналогия:**  Scoreboard можно сравнить с судьей на спортивном соревновании, который сравнивает результаты участников с установленными правилами и определяет победителя.

**6. Agent (Агент):**

* **Роль:** Agent объединяет driver, monitor и sequencer для одного интерфейса DUT.  Он упрощает взаимодействие между этими компонентами и обеспечивает их синхронизацию.
* **Взаимодействие:** Agent содержит в себе driver, monitor и sequencer.  Он взаимодействует с environment и DUT.
* **Аналогия:**  Agent можно сравнить с отделом компании, который отвечает за определенную функцию.  Внутри отдела есть сотрудники, выполняющие разные роли (driver, monitor, sequencer), но все они работают вместе для достижения общей цели.


Взаимодействие этих компонентов в рамках тестового окружения UVM обеспечивает эффективную и структурированную верификацию аппаратного обеспечения.

### Иное
В лекции упоминается транзакционная модель и уровни абстракции как фундаментальные концепции UVM. Они играют важную роль в организации и проведении верификации, обеспечивая эффективное взаимодействие между компонентами тестового окружения и устройством под тестом (DUT).

**Транзакционная модель:**

* **Суть:** В основе транзакционной модели лежит идея представления данных, которыми обмениваются компоненты UVM, в виде объектов, называемых *транзакциями*.  Транзакция инкапсулирует всю необходимую информацию о конкретном событии или операции, например, чтение или запись данных, отправка пакета по сети и т.д.
* **Преимущества:** Использование транзакций позволяет абстрагироваться от деталей реализации интерфейса и сосредоточиться на функциональном поведении системы.  Это упрощает создание тестовых сценариев и делает их более понятными.
* **Пример:**  Представьте, что мы верифицируем контроллер памяти.  Транзакция в этом случае может содержать адрес памяти, данные для записи/чтения, тип операции (чтение или запись) и другие параметры.  Driver будет использовать эту транзакцию для генерации соответствующих сигналов на шине памяти, а monitor будет использовать её для преобразования сигналов с шины обратно в транзакцию для дальнейшего анализа.

**Уровни абстракции (транзакции и сигналы):**

UVM использует два основных уровня абстракции:

1. **Транзакционный уровень:**  На этом уровне компоненты UVM (sequencer, driver, monitor, scoreboard) взаимодействуют друг с другом, обмениваясь транзакциями.  Этот уровень абстрагирован от физической реализации интерфейса и оперирует высокоуровневыми понятиями, такими как чтение, запись, отправка пакета и т.д.

2. **Сигнальный уровень:** На этом уровне происходит взаимодействие с DUT.  Driver преобразует транзакции в физические сигналы, которые подаются на входы DUT.  Monitor, в свою очередь, преобразует сигналы с выходов DUT обратно в транзакции.

**Взаимодействие уровней:**

* **Sequencer -> Driver:** Sequencer генерирует транзакции и отправляет их в driver (транзакционный уровень).
* **Driver -> DUT:** Driver преобразует транзакции в сигналы и подает их на DUT (сигнальный уровень).
* **DUT -> Monitor:** DUT генерирует сигналы на своих выходах в ответ на входные воздействия (сигнальный уровень).
* **Monitor -> Scoreboard (и другие компоненты):** Monitor преобразует сигналы с выходов DUT обратно в транзакции и отправляет их на дальнейшую обработку (транзакционный уровень).

**Преимущества использования уровней абстракции:**

* **Упрощение разработки:** Разделение на уровни абстракции упрощает разработку и отладку тестового окружения. Разработчики могут сосредоточиться на функциональном поведении системы на транзакционном уровне, не вдаваясь в детали реализации интерфейса.
* **Повторное использование:**  Компоненты UVM, работающие на транзакционном уровне, могут быть легко переиспользованы в различных проектах, даже если физическая реализация интерфейса меняется.
* **Гибкость:**  Изменение реализации интерфейса требует только модификации driver и monitor, остальные компоненты остаются неизменными.


Использование транзакционной модели и уровней абстракции делает тестовое окружение UVM более модульным, гибким и масштабируемым.  Это позволяет эффективно верифицировать сложные системы, абстрагируясь от низкоуровневых деталей реализации.

### Классовая структура UVM
Лекция описывает классовую структуру UVM, которая является основой для построения тестовых окружений. Эта структура основана на объектно-ориентированном программировании (ООП) в SystemVerilog и предоставляет набор базовых классов, от которых наследуются все остальные компоненты UVM.

**Ключевые базовые классы:**

* **`uvm_component`:**  Это основной базовый класс для всех компонентов UVM, таких как environment, agent, driver, monitor, sequencer, и scoreboard. Он предоставляет базовые методы для управления компонентами, такие как создание, конфигурация, запуск и завершение.  `uvm_component` также отвечает за иерархию компонентов в тестовом окружении.  Каждый компонент имеет имя и родительский компонент, что позволяет создавать древовидную структуру.

* **`uvm_object`:**  Это базовый класс для всех объектов UVM, включая транзакции (transactions) и sequence items. Он предоставляет методы для копирования, сравнения, печати и записи объектов.  `uvm_object` является более легковесным классом, чем `uvm_component`, и используется для объектов, которые не являются частью иерархии компонентов.  Транзакции, которые передаются между компонентами, обычно наследуются от `uvm_transaction` или `uvm_sequence_item`, которые, в свою очередь, наследуются от `uvm_object`.

* **`uvm_transaction` / `uvm_sequence_item`:**  Эти классы используются для представления транзакций, которыми обмениваются компоненты UVM. `uvm_sequence_item` обычно используется для транзакций, которые генерируются sequencer и отправляются в driver, а `uvm_transaction` – для транзакций, которые собираются monitor.

* **`uvm_sequence`:**  Этот класс используется для создания последовательностей транзакций (sequences).  Последовательности определяют порядок генерации транзакций и могут содержать различные управляющие конструкции, такие как циклы, условия и случайный выбор.

* **`uvm_driver` / `uvm_monitor` / `uvm_scoreboard` / `uvm_agent`:** Эти классы представляют собой базовые классы для соответствующих компонентов UVM (драйвер, монитор, счетчик, агент).  Они предоставляют базовые методы и интерфейсы для этих компонентов.

* **`uvm_factory`:**  Этот класс отвечает за создание объектов и компонентов UVM.  Он позволяет переопределять классы компонентов во время выполнения, что обеспечивает большую гибкость при настройке тестового окружения.

**Наследование:**

Классовая структура UVM основана на наследовании.  Разработчики создают свои собственные классы, наследуя их от базовых классов UVM и добавляя свою специфическую функциональность.  Это позволяет создавать повторно используемые компоненты и упрощает разработку тестовых окружений.

**Полиморфизм:**

UVM также использует полиморфизм, что позволяет объектам разных классов реагировать по-разному на одни и те же методы.  Например, метод `run()` может быть реализован по-разному для driver, monitor и sequencer.

**Преимущества классовой структуры:**

* **Модульность и повторное использование:**  Классы UVM позволяют создавать модульные и повторно используемые компоненты.
* **Стандартизация:**  Стандартизированная классовая структура упрощает взаимодействие между разработчиками и обеспечивает совместимость между различными инструментами верификации.
* **Расширяемость:**  Классовая структура UVM может быть легко расширена для поддержки новых функциональных возможностей.

Классовая структура UVM является основой для построения эффективных и гибких тестовых окружений.  Понимание этой структуры крайне важно для разработки и использования UVM.

### базовые классы UVM
Лекция описывает базовые классы UVM, которые являются фундаментальными строительными блоками для создания тестовых окружений.  Понимание этих классов критически важно для работы с UVM.  Давайте рассмотрим каждый из них подробнее:

**1. `uvm_component`:**

* **Назначение:** Базовый класс для всех *компонентов* UVM. Компоненты – это основные структурные элементы тестового окружения, такие как environment, agent, driver, monitor, sequencer и scoreboard.
* **Функциональность:**  Обеспечивает базовую функциональность для компонентов, включая:
    * **Иерархия:**  Компоненты организованы в иерархическую структуру, подобную дереву. Каждый компонент имеет родителя и может иметь потомков.
    * **Фазы симуляции:**  `uvm_component` определяет набор фаз симуляции (build, connect, run и т.д.), которые обеспечивают упорядоченное выполнение операций в тестовом окружении.
    * **Конфигурация:**  Механизмы для конфигурации компонентов с помощью параметров.
    * **Отчетность:**  Механизмы для генерации сообщений и отчетов.
* **Пример:**  `my_environment` extends `uvm_component`;

**2. `uvm_object`:**

* **Назначение:** Базовый класс для всех *объектов* UVM. Объекты – это экземпляры данных, такие как транзакции (transactions) и configuration objects.  В отличие от компонентов, объекты не имеют иерархии и фаз симуляции.
* **Функциональность:** Предоставляет методы для:
    * **Копирования:**  `clone()`
    * **Сравнения:**  `compare()`
    * **Печати:**  `print()`
    * **Записи:**  `record()`
* **Пример:**  `my_transaction` extends `uvm_object`;

**3. `uvm_transaction` / `uvm_sequence_item`:**

* **Назначение:**  `uvm_sequence_item` – это специализированный тип `uvm_object`, используемый для представления *транзакций*, генерируемых sequencer и передаваемых driver. `uvm_transaction` – более общий базовый класс для транзакций, но чаще всего используется именно `uvm_sequence_item`.
* **Функциональность:**  Помимо функциональности `uvm_object`, добавляет поля и методы, специфичные для транзакций, например, поля для данных, которые передаются через интерфейс.
* **Пример:**  `my_sequence_item` extends `uvm_sequence_item`;

**4. `uvm_sequence`:**

* **Назначение:** Базовый класс для *последовательностей* (sequences). Последовательности определяют порядок генерации транзакций (`uvm_sequence_item`) и отправки их в driver.
* **Функциональность:**  Предоставляет методы для создания и управления последовательностями транзакций, включая циклы, условия, случайный выбор и т.д.
* **Пример:**  `my_sequence` extends `uvm_sequence #(my_sequence_item)`;

**5. `uvm_driver`, `uvm_monitor`, `uvm_scoreboard`:**

* **Назначение:** Базовые классы для драйвера, монитора и счетчика соответственно.
* **Функциональность:**  Предоставляют базовые методы и интерфейсы для этих компонентов.  `uvm_driver` отвечает за отправку транзакций в DUT, `uvm_monitor` – за сбор данных с DUT, а `uvm_scoreboard` – за сравнение полученных и ожидаемых данных.

**6. `uvm_agent`:**

* **Назначение:**  Контейнер, объединяющий driver, monitor и sequencer для одного интерфейса DUT.
* **Функциональность:**  Упрощает взаимодействие между этими компонентами и позволяет управлять ими как единым целым.

**7. `uvm_factory`:**

* **Назначение:**  "Фабрика" объектов и компонентов UVM.
* **Функциональность:**  Позволяет создавать объекты и компоненты по имени класса.  Это позволяет легко переопределять классы компонентов во время выполнения, что обеспечивает большую гибкость при настройке тестового окружения и повторное использование компонентов.


Иерархия и взаимодействие этих базовых классов формируют основу для создания сложных и гибких тестовых окружений в UVM.  Они предоставляют разработчикам мощный инструментарий для верификации аппаратного обеспечения.

## Структура UVM окружения
Структура UVM (Universal Verification Methodology) является стандартом для создания верификационных сред в области проектирования интегральных схем. Она позволяет систематизировать и упростить процесс проверки правильности работы цифровых устройств на уровне RTL (Register Transfer Level). Вот основные компоненты UVM окружения и их взаимосвязь:

1. **UVM Test (test):**
   - Это верхний уровень в иерархии UVM, который определяет и инициализирует проверочное окружение (env).
   - План/сценарий
   - Управляет конфигурацией и выполнением тестовых сценариев.
   - Может содержать специфическую для теста логику и настройки.
2. **UVM Environment (env):**
   - Содержит и интегрирует различные UVM агенты и другие компоненты, такие как scoreboard и monitor.
   - Пространство со всеми инструментами и частями для тестирования
   - Реализует основную проверочную логику и обеспечивает возможность реиспользования в разных тестах.
3. **UVM Agent:**
   - Обычно инкапсулирует sequencer, driver и monitor для определённого интерфейса или функционального блока.
   - Может работать в активном режиме (active mode), управляя передачей последовательностей (sequences), или в пассивном режиме (passive mode), только наблюдая за операциями.
   - Тестируют определённую часть схемы, могут подавать сигналы, могут только наблюдать и записывать изменения 
4. **UVM Sequencer (последователь):**
   - Управляет порядком и выбором UVM последовательностей (sequences), которые должны быть выполнены.
   - Создание последовательности команд для агентов
   - Служит посредником между sequence и driver, передавая sequence items.
5. **UVM Driver (driver):**
   - Преобразует UVM sequence items в сигналы на интерфейсе DUT (Device Under Test).
   - Преоббразует  последовательность команд из **sequencer** в реальные сигналы
   - Взаимодействует с sequencer для получения sequence items и выполнения соответствующих операций на интерфейсе.
6. **UVM Monitor (monitor):**
   - Наблюдает и анализирует сигналы на интерфейсе DUT.
   - Собирает информацию и генерирует события или транзакции, которые передаются в другие компоненты, например, в scoreboard.
7. **UVM Scoreboard:**
   - Сравнивает ожидаемые результаты с фактическими данными, полученными от **monitor**.
   - Осуществляет проверку корректности работы DUT, используя различные алгоритмы сравнения.
8. **UVM Sequence (последовательность):**
   - Сама последовательность операций / определённый сценарий, которые должны быть выполнены в тесте
   - Содержит один или более UVM sequence items, которые описывают отдельные операции.
   - Например, "включить модель, подождать 5 секунд, выключить, проверить состояние".
9. **UVM Sequence Item (элемент последовательности):**
   - Элемент последовательности, который передаётся от sequence через sequencer к driver.
   - Используется для описания одной операции или транзакции для DUT.
   - Это одно действие или команда в большой последовательности. Например, "включить модель" — это один элемент последовательности.

Представим, что ты тестируешь космический корабль LEGO:

- **Тест:** Проверить, может ли корабль стартовать, провести в космосе 10 минут, и затем вернуться.
- **Окружение:** Всё, что связано с космосом и стартом — площадка для запуска, космос, системы навигации.
- **Агенты:** Один агент управляет двигателями, другой следит за системой жизнеобеспечения, третий контролирует навигацию.
- **Последователь:** Сначала активирует двигатели, затем включает навигацию, потом проверяет систему жизнеобеспечения.
- **Драйвер:** Передаёт команды на двигатели (начать работу), на навигационную систему (задать курс) и т.д.
- **Мониторы:** Один следит за двигателями, другой — за кабиной пилота, третий — за траекторией полёта.
- **Табло результатов:** Сравнивает, что корабль действительно стартовал, пробыл в космосе 10 минут и вернулся, как и планировалось.
- **Последовательность действий:** Список команд для полёта.
- **Элементы последовательности:** Каждый шаг в полёте, например, "включить двигатели".

По сути, UVM — это как написание сценария для фильма, где каждый шаг тщательно планируется и проверяется, чтобы в итоге всё работало как надо. Это помогает инженерам быть уверенными в том, что их продукты будут работать правильно в реальном мире!
## Регистрация компонента. UVM Factory.
В UVM (Universal Verification Methodology), фабрика (factory) играет ключевую роль в создании объектов и компонентов, которые используются в тестовом окружении. Это позволяет верификаторам легко менять типы объектов во время выполнения тестов, что делает процесс тестирования более гибким и мощным.
### Регистрация Компонента
Перед тем как использовать компоненты и объекты в UVM, их нужно зарегистрировать в UVM фабрике. Это позволяет фабрике идентифицировать и создавать экземпляры этих классов по запросу. Регистрация компонента обычно выполняется с помощью макроса `uvm_component_utils` для компонентов и `uvm_object_utils` для объектов.

Пример Регистрации Компонента
```systemverilog
class my_component extends uvm_component;
  // Регистрация компонента в UVM фабрике
  `uvm_component_utils(my_component)

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  // Остальные методы компонента...
endclass
```

Пример Регистрации Объекта
```systemverilog
class my_transaction extends uvm_sequence_item;
  // Регистрация объекта (транзакции) в UVM фабрике
  `uvm_object_utils(my_transaction)

  // Конструктор
  function new(string name = "my_transaction");
    super.new(name);
  endfunction

  // Остальные методы...
endclass
```

### UVM Factory и Переопределение (Overriding)
Фабрика UVM позволяет динамически заменять один тип объекта другим, что очень полезно для изменения поведения теста без необходимости изменения исходного кода тестового окружения. Есть два основных типа переопределения:

1. **Type Overriding (Переопределение по типу)**: Это позволяет заменить один тип объекта другим глобально, во всём тесте.
   - **`set_type_override`** - используется для переопределения типа объекта на другой тип. Когда фабрика сталкивается с запросом на создание объекта исходного типа, она вместо него создаёт объект нового типа.

   ```systemverilog
   // Переопределение типа my_transaction на my_custom_transaction
   factory.set_type_override_by_type(my_transaction::get_type(), my_custom_transaction::get_type());
   ```

2. **Instance Overriding (Переопределение по экземпляру)**: Это позволяет заменить тип объекта для конкретного экземпляра или пути в иерархии компонентов.
   - **`set_inst_override`** - используется для переопределения типа объекта для конкретного экземпляра или пути. Это означает, что переопределение применяется только к указанному пути в иерархии компонентов.

   ```systemverilog
   // Переопределение типа my_component на my_custom_component только для экземпляра "env.agent1"
   factory.set_inst_override_by_type("env.agent1", my_component::get_type(), my_custom_component::get_type());
   ```
	
## Переопределение компонента по типу.
Синтаксис переопределения по типу выглядит следующим образом:

```verilog
<original_type>::type_id::set_type_override(<substitute_type>::get_type(), replace);
```

## Переопределение компонента по имени экземпляра.
Синтаксис переопределения по имени определенного экземпляра выглядит следующим образом:
```verilog
<original_type>::type_id::set_inst_override(<substitute_type>::get_type(), <path_string>);
```

## Структура по фазам
Структура UVM (Universal Verification Methodology) по фазам — это ключевая концепция, которая обеспечивает структурированный и последовательный подход к верификации. В UVM каждая часть тестового процесса разделена на фазы, и каждая фаза имеет свои задачи и цели. Эти фазы помогают организовать выполнение теста, управление ресурсами и анализ результатов.

![](../../images/Pasted%20image%2020241203215645.png)
### Основные Фазы UVM

Фазы в UVM помогают в определении жизненного цикла компонентов и тестового окружения. Вот основные фазы, через которые проходит UVM тест:

1. **Build Phase (`build_phase`):**
   - **Цель:** Создание и конфигурирование тестового окружения.
   - **Что происходит:** В этой фазе создаются все UVM компоненты, такие как агенты, мониторы и scoreboard. Компоненты конфигурируются с использованием UVM конфигурационного DB (database).
   - **Методы:** Компоненты определяют метод `build_phase(uvm_phase phase)`, в котором они создают и конфигурируют свои субкомпоненты.
2. **Connect Phase (`connect_phase`):**
   - **Цель:** Соединение компонентов тестбенча.
   - **Что происходит:** В этой фазе устанавливаются связи между компонентами, например, соединение мониторов со scoreboard или установка TLM-портов и экспортов.
   - **Методы:** Компоненты определяют метод `connect_phase(uvm_phase phase)`, который используется для установления соединений.
3. **End of Elaboration Phase (`end_of_elaboration_phase`):**
   - **Цель:** Финализация структуры тестбенча.
   - **Что происходит:** В этой фазе завершается подготовка тестового окружения перед началом выполнения. Это включает в себя завершение всех динамических соединений и проверку конфигураций.
   - **Методы:** Метод `end_of_elaboration_phase(uvm_phase phase)` вызывается для каждого компонента.
4. **Start of Simulation Phase (`start_of_simulation_phase`):**
   - **Цель:** Подготовка к началу симуляции.
   - **Что происходит:** Это последняя фаза перед началом активной симуляции. В этой фазе можно выполнить финальные проверки или инициализации.
   - **Методы:** Метод `start_of_simulation_phase(uvm_phase phase)` вызывается для каждого компонента.
5. **Run Phase (`run_phase`):**
   - **Цель:** Выполнение основной логики теста.
   - **Что происходит:** Это основная фаза, в которой происходит симуляция. В этой фазе запускаются последовательности, генерируются и обрабатываются транзакции, собираются данные мониторинга.
   - **Методы:** Компоненты определяют метод `run_phase(uvm_phase phase)`, в котором описывается основная логика работы компонента.
6. **Extract Phase (`extract_phase`):**
   - **Цель:** Извлечение данных после теста.
   - **Что происходит:** В этой фазе извлекаются результаты мониторинга и другие данные, которые могут быть использованы для анализа работы DUT.
   - **Методы:** Метод `extract_phase(uvm_phase phase)` используется для извлечения и сохранения результатов работы теста.
7. **Check Phase (`check_phase`):**
   - **Цель:** Проверка результатов теста.
   - **Что происходит:** Это фаза, в которой анализируются результаты, собранные в фазе extract, и проверяется, соответствуют ли они ожиданиям.
   - **Методы:** Метод `check_phase(uvm_phase phase)` используется для проверки результатов симуляции.
8. **Report Phase (`report_phase`):**
   - **Цель:** Отчёт о результатах теста.
   - **Что происходит:** В этой фазе формируются и выводятся отчёты о проведённом тестировании, включая информацию о покрытии, найденных ошибках и других ключевых моментах.
   - **Методы:** Метод `report_phase(uvm_phase phase)` используется для генерации отчётов о тестировании.
9. **Final Phase (`final_phase`):**
   - **Цель:** Завершение теста.
   - **Что происходит:** Это финальная фаза, в которой выполняются все необходимые действия для корректного завершения симуляции, например, закрытие файлов и освобождение ресурсов.
   - **Методы:** Метод `final_phase(uvm_phase phase)` вызывается для корректного завершения работы UVM теста.

## Пример построения тестового окружения по методологии UVM.
Фигня какая-то можно не рассматривать

```verilog
interface SUM_IF;
	logic clk;
	logic [7:0] a, b;
	logic [8:0] out;
	
modport standard (
	input clk, a, b,
	output out
);

endinterface
```

```verilog
module sum (SUM_IF.standard io);
	always@(posedge io.clk)
		io.out <= io.a + io.b;
endmodule
```
## Конфигурационная база
Конфигурационная база в UVM (Universal Verification Methodology) — это механизм, который позволяет компонентам UVM обмениваться конфигурационной информацией во время выполнения. Это важная часть UVM, поскольку она обеспечивает гибкость и масштабируемость тестовых сред, позволяя параметризировать и настраивать компоненты динамически, без изменения их кода.

Можно сказать что это как рюкзак, в котором ты можешь хранить разные вещи (настройки) и доставать их, когда они тебе нужны, в любом месте твоего теста.

Конфигурационная база UVM используется для:
1. **Передачи параметров между компонентами:** Это может включать такие вещи, как виртуальные интерфейсы, настройки политик (policies), размеры буферов и другие параметры, которые должны быть переданы между различными частями тестбенча.
2. **Динамической настройки компонентов:** Она позволяет изменять поведение компонентов во время выполнения на основе заданных параметров, что делает тесты более адаптивными и универсальными.
3. **Управления конфигурациями для разных уровней иерархии:** Конфигурационная база позволяет устанавливать параметры на различных уровнях иерархии UVM, обеспечивая тем самым гранулярное управление конфигурациями.

![](../../images/Pasted%20image%2020241203215901.png)
### Как Работает Конфигурационная База
UVM предоставляет класс `uvm_config_db` для управления конфигурациями. Основные методы этого класса:
- **set:** Записывает значение в конфигурационную базу.
- **get:** Читает значение из конфигурационной базы.

### здесь должен был быть нормальный пример но его нет

### Пример с Рюкзаком

Конфигурационная база в UVM — это как рюкзак для тестировщика: ты можешь заранее подготовить все необходимые настройки и инструменты, а затем использовать их в нужный момент, чтобы сделать тестирование гибким и эффективным. Это позволяет легко менять параметры и адаптировать тест под разные условия, не перестраивая весь тест с нуля.

Допустим, ты идёшь в поход и у тебя есть рюкзак. В этом рюкзаке ты можешь хранить воду, карту, компас и другие вещи. Когда ты хочешь что-то взять, ты просто достаёшь это из рюкзака.

- **Установка вещи в рюкзак:** Ты кладёшь в рюкзак карту. Это как если бы в тесте ты "устанавливал" параметр.
```systemverilog
uvm_config_db#(virtual SUM_IF)::set(null, "*", "vif", vif);
```
Здесь ты говоришь: "В моём тестовом мире (в рюкзаке) для всех компонентов (`"*"`) я хочу использовать эту карту (`vif`) и называю её `'vif'`."

- **Получение вещи из рюкзака:** Ты достаёшь карту из рюкзака, когда ты на перекрёстке и не знаешь, куда идти. Это как получение параметра в компоненте.
```systemverilog
if (!uvm_config_db#(virtual SUM_IF)::get(this, "", "vif", vif)) begin
`uvm_fatal("DRV", "Virtual interface not found")
end
```
Здесь ты говоришь: "Мне нужна моя карта (`'vif'`) из рюкзака, чтобы понять, куда мне идти. Если в рюкзаке нет карты, я в замешательстве и ошибка (`uvm_fatal`)."

1. **Как передать настройки в тест?**
Если бы ты готовился к походу, ты бы решил, что берёшь с собой, основываясь на погоде или плане похода. В UVM это как задать параметры для теста:

- **Установить параметры:** Представь, что ты решаешь, какую куртку брать - лёгкую ветровку или тёплую куртку. Это как установить параметр:
```systemverilog
uvm_config_db#(int)::set(uvm_root::get(), "env.agent.*", "buffer_size", 1024);
```
Здесь ты говоришь: "Для всех агентов в моём тестовом окружении я хочу установить размер буфера в 1024 (как выбрать размер рюкзака)."

- **Получить параметры:** Когда ты начинаешь упаковывать рюкзак, ты смотришь на погоду и решаешь, какую куртку брать.
```systemverilog
if (!uvm_config_db#(int)::get(this, "", "buffer_size", buffer_size)) begin
buffer_size = 256;  // Если не нашёл в рюкзаке инфо, беру лёгкую ветровку.
end
```
Здесь ты говоришь: "Мне нужно знать, какой размер буфера использовать (какую куртку взять). Если я не нашёл эту информацию, я возьму стандартный размер (ветровку)."

2. **Динамическое изменение поведения**
Это как изменить план похода, когда ты уже на тропе. Если начинается дождь, ты достаёшь дождевик из рюкзака.

- **Установить режим работы агента:**
```systemverilog
uvm_config_db#(bit)::set(uvm_root::get(), "env.agent", "is_active", 1'b1);
```
Здесь ты говоришь: "Я хочу, чтобы мой агент был активным (как решить идти на сложный маршрут)."

- **Получить режим работы агента:**
```systemverilog
if (!uvm_config_db#(bit)::get(this, "", "is_active", is_active)) begin
is_active = 1'b0;  // Если не установлено, будем считать, что маршрут лёгкий.
end
```

Здесь ты говоришь: "Мне нужно знать, активен ли мой агент (иду ли я по сложному маршруту). Если нет информации, я выберу лёгкий путь."

## ГОСТ 21552-84. ГОСТ 2.103-2013. ГОСТ 19.301-79. ГОСТ Р 71267-2024. IEEE 1076. IEEE 1364. IEEE 1800. IEEE 1149.1. IEEE 1500. IEEE 1685. IEEE 1735. IEEE 1801. IEEE 1666.
- ГОСТ 21552-84: Общие технические требования, приемка. методы испытаний, маркировка, упаковка, транспортирование и хранение. 
- ГОСТ 2.103-2013: "Единая система конструкторской документации (ЕСКД). Общие требования к текстовым документам." Этот стандарт устанавливает общие требования к оформлению текстовых документов, входящих в состав конструкторской документации.
- ГОСТ 19.301-79: "Единая система программной документации (ЕСПД). Техническое задание. Требования к содержанию и оформлению." Определяет стандарты на содержание и оформление технического задания на разработку программного обеспечения.
- ГОСТ Р 71267-2024: Системы автоматизированного проектирования электроники. Маршрут проектирования и верификации программируемых логических интегральных схем. Настоящий стандарт предназначен для применения предприятиями промышленности и организациями при использовании электронных систем проектирования и верификации ПЛИС. Особенности устройства и функционирования ПЛИС требуют применения интегрированных систем, содержащих в своем составе инструменты разработки загружаемого в ПЛИС кода, определяющего функционирование ПЛИС в составе аппаратуры. Такие системы проектирования и верификации ПЛИС позволяют создавать и моделировать проект, загружаемый в ПЛИС, с использованием принципиальных электрических схем, схем машин состояний, а также языков описания аппаратуры на уровне регистровых передач (RTL languages)

- IEEE 1076 — "Standard VHDL Language Reference Manual." Этот стандарт определяет VHDL (VHSIC Hardware Description Language), язык описания аппаратуры, используемый для моделирования и проектирования электронных систем.
- IEEE 1364 — "Standard Verilog Hardware Description Language." Этот стандарт описывает Verilog, язык для моделирования и проектирования электронных систем, аналогичный VHDL.
- IEEE 1800 — "Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language." Этот стандарт расширяет Verilog, включая возможности для более высокоуровневого моделирования и верификации.
- IEEE 1149.1 — "Standard Test Access Port and Boundary-Scan Architecture." Описывает архитектуру для тестирования и диагностики цифровых устройств с использованием граничного сканирования (JTAG).
- IEEE 1500 — "Standard for Embedded Core Test." Стандарт, который определяет методологию тестирования встроенных модулей в микроэлектронных чипах.
- IEEE 1685 — "Standard for IP-XACT, Standard Structure for Packaging, Integrating, and Reusing IP within Tool Flows." Описывает формат XML для описания метаданных интеллектуальных свойств (IP) компонентов электроники.
- IEEE 1735 — "Standard for Encryption and Management of Electronic Design Intellectual Property (IP)." Этот стандарт определяет методы шифрования и управления интеллектуальной собственностью в электронном дизайне.
- IEEE 1801 — "Standard for Design and Verification of Low Power Integrated Circuits." Стандарт, известный как Unified Power Format (UPF), для описания и верификации низкопотребляющих интегральных схем, позволяющий определять и управлять энергопотреблением на уровне проекта цифровых систем.
- IEEE 1666 - "Standard SystemC Language Reference Manual." Этот стандарт определяет SystemC, язык моделирования на уровне системы, используемый для быстрого прототипирования и верификации сложных электронных систем и встроенных систем. SystemC предоставляет возможности для описания аппаратуры и программного обеспечения на высоком уровне.

Вместе эти стандарты обеспечивают основу для проектирования, тестирования, верификации и документирования широкого спектра электронных систем и программного обеспечения. Важно отметить, что стандарты IEEE в основном используются в международной практике и применяются для разработки микроэлектроники и программирования, тогда как ГОСТы применяются в странах СНГ и определяют требования к продукции и процессам на территории этих стран.

Каждый из этих стандартов играет ключевую роль в унификации процессов, методов и компонентов, что позволяет улучшить совместимость, повысить качество продукции и облегчить международное сотрудничество в области разработки и производства электронных и программных продуктов.


