# 9. Частичная реконфигурация.
## Понятие частичной реконфигурации в контексте ПЛИС.
Частичная реконфигурация (Partial Reconfiguration) - технология, позволяет изменять часть конфигурации FPGA без полного перезагрузки устройства. Это означает, что можно обновлять или заменять отдельные функциональные блоки (например, Function C2 или Function B2) в FPGA, в то время как остальные части продолжают работать.

![](../attachments/Pasted%20image%2020241217181112.png)

Архитектура FPGA:
- FPGA состоит из множества конфигурируемых логических блоков (CLB), связей и входов-выходов (I/O).
- Это достигается за счет того, что CLB организованы в конфигурационные фреймы, и частичная реконфигурация обновляет только необходимые фреймы. Частичная реконфигурация изменяет конфигурацию только выбранных CLB, сохраняя остальные блоки в рабочем состоянии.

Битовые файлы:
- Полный битовый файл: Содержит данные для полной конфигурации FPGA. Содержит всю информацию, необходимую для полной конфигурации FPGA. Загружается при первичной настройке устройства или при необходимости полной переработки функциональности. Обеспечивает начальное состояние всех CLB, связей и I/O.
- Частичные битовые файлы: Содержат данные для изменения только специфических участков FPGA. Содержат информацию только для обновления выбранных участков FPGA. Создаются на этапе проектирования для определенных областей, которые будут изменяться в процессе работы. Загружаются через конфигурационные порты, чтобы изменить функциональность только в нужных частях без прерывания работы всей системы.

Порты конфигурации:
- Конфигурационный порт: Используется для загрузки как полных, так и частичных битовых файлов.
- ICAP (Internal Configuration Access Port): Позволяет загружать частичные битовые файлы из внутренней логики FPGA.

Процесс частичной реконфигурации:
- Определение областей FPGA, которые будут реконфигурированы.
- Создание частичных битовых файлов для этих областей.
- Загрузка частичных битовых файлов через конфигурационный порт или ICAP.
- Обновление конфигурации в реальном времени без остановки всей системы.

## Преимущества применения.
Частичная реконфигурация FPGA предоставляет значительные преимущества в различных аспектах разработки и эксплуатации вычислительных систем. Вот как это работает:

### Повышение гибкости вычислительной системы
- **Адаптивность**: FPGA может динамически изменять свою конфигурацию для выполнения разных задач без замены аппаратной части. Это позволяет использовать одно устройство для множества функций, адаптируясь к изменяющимся условиям и требованиям.
- **Модульность**: Возможность обновлять или заменять части системы без влияния на остальные компоненты, что упрощает разработку и тестирование новых функций.

### Сокращение числа требуемых ресурсов и стоимости разработки
- **Экономия на оборудовании**: Возможность использования одного FPGA для выполнения разных задач в разное время позволяет сократить количество устройств, необходимых для реализации проекта.
- **Уменьшение затрат на разработку**: Поскольку одна и та же аппаратная платформа может использоваться для различных приложений, это снижает затраты на проектирование и производство индивидуальных устройств для каждой задачи.

### Снижение расхода мощности
- **Эффективность использования ресурсов**: Частичная реконфигурация позволяет отключать неиспользуемые части FPGA, снижая общее энергопотребление устройства.
- **Оптимизация производительности**: Изменение конфигурации может быть направлено на оптимизацию алгоритмов и маршрутизации, что дополнительно снижает потребление энергии.

### Возможность обновления (исправления) для развернутых систем
- **Исправление ошибок**: Позволяет вносить изменения и исправления в уже развернутые системы без необходимости их физической замены, что особенно важно для систем, находящихся в труднодоступных местах.
- **Улучшение функциональности**: Системы могут обновляться с добавлением новых функций или улучшением существующих, оставаясь актуальными и конкурентоспособными.
- **Минимизация времени простоя**: Обновления могут проводиться без остановки всей системы, что критично для систем с высокими требованиями к доступности и надежности.

Эти преимущества делают частичную реконфигурацию FPGA мощным инструментом для создания гибких, экономичных и энергоэффективных вычислительных систем.

1. **Экономия ресурсов ПЛИС**: Частичная реконфигурация позволяет использовать одни и те же ресурсы ПЛИС для разных задач в разное время, оптимизируя таким образом их использование.
2. **Уменьшение потребления энергии**: Загрузка только необходимых частей схемы может снижать общее энергопотребление.
3. **Повышение гибкости системы**: Можно адаптировать поведение ПЛИС под различные задачи на лету, что делает систему более адаптивной к изменяющимся условиям.
4. **Увеличение производительности**: Оптимизация использования ресурсов может привести к более высокой производительности для конкретных задач.
5. **Снижение затрат**: Вместо использования нескольких специализированных устройств можно использовать одно ПЛИС с частичной реконфигурацией.

## Примеры систем, в которых оправдано использование технологии.
1. **Телекоммуникационные системы**: Для адаптации к различным стандартам связи в реальном времени.
2. **Военная техника**: Необходимость быстрого изменения функционала в полевых условиях.
3. **Пространственные исследования**: Адаптация к изменяющимся условиям и задачам в космических миссиях.
4. **Обработка сигналов и изображений**: Динамическое изменение алгоритмов обработки.
5. **Робототехника**: Переконфигурация для выполнения различных задач адаптации к окружающей среде.

### Примеры использования. Коммуникационный узел (Hub)
![](../attachments/Pasted%20image%2020241217181128.png)

Коммуникационный узел может динамически переключаться между различными функциями, такими как обработка видео, радиосвязь и работа с шиной данных. Это достигается с помощью частичной реконфигурации FPGA, которая позволяет обновлять или заменять функциональные блоки без прерывания работы всей системы.

### Компоненты
- PR Region 1: Обработка видео. Может включать кодек для сжатия или декомпрессии видео, фильтры для улучшения качества изображения или алгоритмы для распознавания образов. В этой области может выполняться преобразование видеопотока для отображения на мониторе.
- PR Region 2: Радиосвязь. Обеспечивает модуляцию и демодуляцию сигналов для беспроводной передачи данных. Может адаптироваться к различным стандартам связи, таким как Wi-Fi, Bluetooth или специализированные протоколы.
- PR Region 3: Работа с шиной данных. Обрабатывает входящие и исходящие данные через интерфейс шины. Поддерживает различные протоколы, такие как PCIe или Ethernet, в зависимости от требований.

В контексте коммуникационного узла (hub) термины "video link," "bus link," и "radio link" обозначают различные типы соединений для передачи данных

### Примеры использования. Мультиплексирование с разделением по времени
![](../attachments/Pasted%20image%2020241217181142.png)

Мультиплексирование с разделением по времени (TDM) — это метод передачи нескольких сигналов по одному каналу связи путем разделения времени на несколько интервалов. Каждый сигнал передается в своем временном интервале (таймслоте), что позволяет эффективно использовать пропускную способность канала.

### Как работает TDM:
1. Разделение времени на таймслоты: Канал связи разбивается на последовательные временные интервалы, называемые таймслотами. Каждый таймслот выделяется для передачи определенного сигнала или данных от одного источника.
2. Циклическое распределение таймслотов: Таймслоты повторяются циклически, что позволяет каждому сигналу передаваться на регулярной основе. Например, если у нас есть четыре источника данных (A, B, C, D), таймслоты могут распределяться следующим образом: [A, B, C, D, A, B, C, D, ...].
3. В традиционных телефонных сетях TDM используется для объединения нескольких телефонных разговоров на одной линии связи. Каждый разговор передается в своем временном интервале, что позволяет эффективно использовать пропускную способность линии.

Хранилище конфигурационной памяти позволяет динамически изменять функциональность FPGA, загружая и выгружая необходимые конфигурации, а порты обеспечивают интерфейс для взаимодействия с внешними устройствами или сетями. В зависимости от текущих задач или условий, FPGA может загружать необходимую конфигурацию из хранилища конфигурационной памяти. Например, если требуется обработка данных через 10 GigE, соответствующая конфигурация загружается в FPGA и подключается к Port 1.

1. Configuration Memory Storage (Хранилище конфигурационной памяти):
- - Хранилище содержит различные конфигурации для FPGA, такие как 10 GigE, OC48, Fibre, Custom и другие. 10 GigE (10 Gigabit Ethernet) – для высокоскоростной передачи данных. OC48 – для передачи данных через оптические сети. Fibre – для передачи данных через оптоволоконные каналы. Custom – пользовательские конфигурации для специальных задач.
- - Каждая конфигурация представлена как набор блоков "tx/rx" (передатчик/приемник), которые могут быть загружены в FPGA по мере необходимости.
2. FPGA:
- - Внутри FPGA расположена "Switch Fabric" (коммутационная ткань), которая управляет потоками данных между различными конфигурациями и портами.
  - FPGA может быть частично реконфигурирован для загрузки различных блоков конфигураций (например, 10 GigE, OC48 и т.д.) на определенные порты (Port 1, Port 2, Port 3, Port 4). Это означает, что не вся FPGA переконфигурируется целиком, а только её части, что позволяет быстро изменять функциональность устройства.
3. Порты:
- - Порты 1, 2, 3 и 4 подключены к различным конфигурациям, загруженным из хранилища конфигурационной памяти в FPGA.
  - Например, к Port 1 подключена конфигурация 10 GigE, к Port 2 - OC48, к Port 3 - Fibre, к Port 4 - Custom.

### Пример. Различные варианты ускорителей для СнК
![](../attachments/Pasted%20image%2020241217181153.png)

На представленных изображениях показан пример частичной реконфигурации (Partial Reconfiguration) для системы на кристалле (СнК), основанный на архитектуре Zynq-7000 SoC.

Объяснение изображений:
- Левое изображение демонстрирует структуру Zynq-7000 SoC, которая включает два основных компонента:
  - Processing System (PS): Это процессорная система, включающая в себя процессорные ядра ARM, периферийные устройства, память и интерфейсы. Она обычно отвечает за выполнение программного кода, управление и координацию работы системы.
  - Programmable Logic (PL): Это программируемая логика, которая может быть настроена для выполнения специфических аппаратных задач и ускорения вычислений.
- Эти два компонента соединены интерфейсами AXI, которые позволяют обмениваться данными между процессорной системой и программируемой логикой.
- Правое изображение иллюстрирует процесс частичной реконфигурации, который позволяет изменять часть программируемой логики (PL) без необходимости полности перезагружать весь битовый файл
  - ICAP (Internal Configuration Access Port): Это внутренняя конфигурационная шина, которая позволяет загружать и применять новые конфигурации для части программируемой логики.
  - Static: Это статическая часть логики, которая остается неизменной во время частичной реконфигурации.
  - PCIe: Интерфейс PCIe, который может быть использован для связи с другими устройствами.
  - Full Bit File: Полный битовый файл, содержащий всю конфигурацию программируемой логики.
  - Partial Bit File: Частичный битовый файл, содержащий конфигурацию только для изменяемой части логики.

## Статические и динамические области.
Статическая область — это часть аппаратной конфигурации, которая не изменяется во время работы устройства. Эта область содержит постоянные компоненты цепи, такие как:
- Центральный процессор или микропроцессорные блоки.
- Постоянные соединения и шины данных.
- Периферийные устройства и интерфейсы.
- Логика управления, не участвующая в реконфигурации.

Динамическая или реконфигурируемая область (RP) — это сегмент аппаратного обеспечения, который может изменять свою конфигурацию в реальном времени в зависимости от требований задачи. В каждой такой области можно загружать различные модули (Reconfigurable Modules, RM), которые изменяют функциональность области, но без влияния на статические области. Примеры использования:
- Адаптация к новым алгоритмам обработки данных.
- Переключение между различными протоколами связи.
- Оптимизация вычислений для разных операций.

Модули для реконфигурации (RM) — это отдельные блоки логики, которые можно загружать в реконфигурируемую область. Каждый модуль предназначен для выполнения определённой функции, и его можно подменять на другой при необходимости. Примеры модулей:
- RM1_A, RM1_B, RM1_C для RP1.
- RM2_A, RM2_B для RP2.
- RM3_A, RM3_B, RM3_C для RP3.
  
Каждая реконфигурируемая область может содержать один активный модуль в любой момент времени, и переключение между модулями позволяет менять функциональность оборудования без физического вмешательства в аппаратную структуру.

### Пример
- RP1 может быть сконфигурирован с одним из модулей RM1_A, RM1_B, или RM1_C. Например, RM1_A может быть процессором для обработки видео, RM1_B — для обработки аудио, а RM1_C — для шифрования данных.
- RP2 может использовать RM2_A или RM2_B, где RM2_A может быть модулем для сетевого взаимодействия, а RM2_B — для анализа данных.
- RP3 с модулями RM3_A, RM3_B, RM3_C, которые могут быть специализированы под разные задачи машинного обучения или обработки сигналов.

Разные RM в одной RP могут выполнять как одну и ту же задачу разными способами, так и разные задачи. 

1. Выполнение разных задач:
  - Разнообразие функций: Каждый модуль RM в реконфигурируемой области RP выполняет уникальную функцию. Это позволяет адаптировать вычислительные ресурсы под разные задачи в зависимости от текущих потребностей системы.
  - Пример: Если RP1 содержит модули RM1_A, RM1_B, и RM1_C, то RM1_A может обрабатывать видео, RM1_B — аудио, а RM1_C — выполнять шифрование данных.
2. Выполнение одной задачи разными способами:
  - Оптимизация и адаптация: Модули RM могут быть разными реализациями одной и той же функции, оптимизированными под разные условия работы. Например, один модуль может быть оптимизирован для высокой скорости работы, другой — для минимального энергопотребления, а третий — для работы с максимальной точностью.
  - Пример: Все модули RM1_A, RM1_B, и RM1_C могут выполнять обработку видеосигналов, но каждый использует разные алгоритмы или параметры (например, разные кодеки или фильтры).
3. Резервирование и отказоустойчивость:
  - Отказоустойчивость: Модули RM могут быть дублирующими реализациями одной и той же задачи для повышения надёжности системы. В случае выхода из строя одного модуля, система может переключиться на другой модуль с той же функциональностью.
  - Пример: RM1_A и RM1_B могут быть двумя версиями модуля для обработки видео. Если RM1_A выходит из строя, система переключается на RM1_B без потери функциональности.
4. Поддержка разных версий или конфигураций:
  - Версионность: Разные модули могут представлять собой разные версии одного и того же алгоритма, позволяя переключаться между версиями без полной перепрограммирования устройства.
  - Пример: RM1_A, RM1_B, и RM1_C могут быть разными версиями алгоритма обработки данных, каждый из которых оптимален для разных условий эксплуатации или разных версий стандартов.

В процессе имплементации создается набор **полных конфигураций**, каждая из которых содержит статическую логику и один вариант для каждого модуля.

Количество конфигураций для каждой из динамических областей определяется, исходя из максимального количества модулей для реконфигурации.

## Реконфигурируемые ресурсы ПЛИС.
1. **Ячейки ПЛИС и их компоненты:**
   - **LUTs (Look-Up Tables):** Основные логические элементы в ПЛИС, которые могут быть настроены для выполнения различных логических функций и операций. LUTs могут также использоваться как небольшие блоки памяти.
   - **Flip-flops:** Базовые элементы для хранения состояния (битов) и создания регистров и других синхронных структур.
   - **Carry chains:** Специализированные структуры для ускорения арифметических операций, особенно сложения и вычитания.
2. **Память:**
   - **BRAM (Block RAM):** Блочная память, которая может быть настроена для хранения больших объёмов данных и используется для создания FIFO, RAM, ROM и других структур.
   - **DRAM (Distributed RAM):** Использует LUTs как память, позволяя создавать мелкозернистые памятные структуры.
   - **LUT как сдвиговый регистр:** Настройка LUTs для работы в режиме сдвиговых регистров, что позволяет эффективно реализовывать задержки, буферы и другие временные структуры.
3. **Блоки DSP (Digital Signal Processing):**
   - Эти блоки предназначены для выполнения сложных арифметических операций (умножение, аккумуляция, и т.д.) и используются в DSP задачах, таких как обработка сигналов, видео и аудио данных.
4. **Компоненты ввода/вывода:**
   - **IOLOGIC:** Блоки для управления логикой ввода/вывода, включая сериализацию/десериализацию и другие функции.
   - **IODELAY, IDELAYCTRL:** Блоки для настройки задержек в линиях ввода/вывода, что критично для согласования времени и работы с высокоскоростными интерфейсами.

### Ресурсы в Статической Области
Статическая область содержит компоненты, которые не изменяются:
1. **Блоки ресинхронизации:**
   - **MMCM (Mixed-Mode Clock Manager), DCM (Digital Clock Manager), PLL (Phase-Locked Loop):** Эти блоки используются для генерации и управления тактовым сигналом, включая деление частоты, умножение и фазовую синхронизацию.
   - **PMCD (Power Management Controller):** Управляет питанием и энергопотреблением устройства.
2. **Глобальные тактовые буферы (BUFG):**
   - Распределяют тактовый сигнал по всей ПЛИС с минимальной задержкой и синхронизацией.
3. **Дополнительные блоки:**
   - **BSCAN (Boundary Scan), ICAP (Internal Configuration Access Port), STARTUP:** Вспомогательные блоки для тестирования, конфигурации и управления запуском.
   - **PCIE (PCI Express):** Интерфейс для подключения к внешним шинам и устройствам.

## Рекомендации при использовании частичной реконфигурации.
### 1. **Использование развязывающей логики**
Развязывающая логика играет ключевую роль в изоляции переконфигурируемой области от статической части схемы. Это помогает предотвратить неопределённое поведение и ошибки:
- **Использование Tri-state Buffers (трёхсостоянийный буфер):**  тип электронного буфера, который может находиться в одном из трёх состояний. Высокоимпедансное состояние (High-Z or 'Z') — состояние, при котором выход буфера "отключается" и не оказывает влияния на линию, к которой он подключен. Они могут использоваться для временного "отключения" сигналов, идущих в динамическую область или выходящих из неё, что предотвращает возможные конфликты и помехи во время реконфигурации. Это обеспечивает физическую изоляцию, позволяя сигналам быть подключенными или отключенными в зависимости от состояния реконфигурации.
- **Использование Bus macros** — это специализированные структуры, используемые в ПЛИС для обеспечения надёжного соединения между статической и динамической областями. Они работают как мосты, которые: Передают сигналы между областями, когда это безопасно. Блокируют передачу сигналов в критические моменты, например, во время реконфигурации.
### 2. **Отключение переконфигурируемой области**
До и во время процесса реконфигурации переконфигурируемая область должна быть полностью изолирована от статической части и внешнего интерфейса:
- **Disable Internal Logic:** Все внутренние сигналы, ведущие в переконфигурируемую область и из неё, должны быть отключены или поставлены в безопасное состояние.
- **External Interfaces:** Если переконфигурируемые модули подключены к внешним выводам FPGA, убедитесь, что они отключены на уровне внешней схемы или через дополнительные внешние элементы развязки.
### 3. **Использование проектных ограничений для временных задержек**
Тщательно специфицируйте временные ограничения для всех сигналов, взаимодействующих с переконфигурируемой областью:
- **Timing Constraints:** Установите строгие временные ограничения для интерфейсов между статической и динамической областями, чтобы избежать гонок данных и других временных проблем.
### 4. **Использование синхронного стиля проектирования**
Все блоки и модули должны следовать принципам синхронного проектирования, чтобы минимизировать проблемы синхронизации:
- **Clock Domains:** Убедитесь, что все взаимодействия между статической и динамической областями происходят в рамках чётко определённых тактовых доменов.
- **Synchronous Reset:** Используйте синхронные сигналы сброса для всех модулей, взаимодействующих с переконфигурируемой областью.
### 5. **Иерархическая структура проекта**
Структурируйте ваш проект так, чтобы статическая и динамическая области были чётко разделены:
- **Modular Design:** Разрабатывайте систему в виде модулей с чёткими интерфейсами, что упрощает реконфигурацию и повышает надёжность системы.
### 6. **Установка дополнительных регистров на входы и выходы реконфигурируемых модулей (RM)**
Это поможет минимизировать проблемы с временем установки и удержания, а также улучшит общую стабильность взаимодействия:
- **Input and Output Registers:** Введение флип-флопов на границах переконфигурируемых модулей обеспечивает дополнительную стабильность и позволяет лучше контролировать временные параметры.
- Стабильность данных на границах RM за счет "захвата" и "выпуска" данных строго по тактовым сигналам.
- Предотвращение ошибок в данных, вызванных асинхронными изменениями и гонками данных. Гонка данных возникает, когда два или более процесса пытаются одновременно читать и записывать одни и те же данные без должной синхронизации, что может привести к неопределенным результатам.
- Улучшенное управление реконфигурацией, так как старые данные сохраняются до полного обновления функционала модуля.
### 7. **Контроль fan-out для реконфигурируемых модулей**
Управление фанаутом (количество логических элементов, управляемых одним выходом без ухудшения характеристик этого выхода) важно для обеспечения стабильности и производительности:
- **Manage Fan-Out:** Ограничьте фанаут для критических сигналов, чтобы избежать проблем с загрузкой и временем распространения сигнала. Во время реконфигурации модуля (RM) изменение структуры схемы может влиять на fan-out отдельных выходов. Если новая конфигурация ведет к увеличению fan-out за пределы допустимого, это может снизить скорость работы модуля или даже привести к ошибкам в логике из-за увеличения времени задержек.
- Пример Уменьшения Fan-Out: Рассмотрим ситуацию, когда выход X из статической области ПЛИС должен подключаться к входам нескольких реконфигурируемых модулей RM1, RM2, ..., RMn:
  - Без Буферизации:
    - Если выход X напрямую подключен к входам всех модулей, `fan-out = n`.
    - При большом n это увеличивает задержки и риски некорректной работы.
  - С Буферизацией:
    - Можно ввести буферы (например, буферы типа 74LS244) или специализированные драйверы линий.
    - Эти буферы разделяют нагрузку, эффективно уменьшая fan-out для каждой ветви.
    - Также они делают усиление сигнала, Разделение Нагрузки, Изоляция Сегментов Схемы, Повышение Надежности, Управление Помехами.

![](../attachments/Pasted%20image%2020241217181230.png)

1. **Первый вариант (слева)**:
   - Реконфигурируемый модуль (ff2, RM) находится между статическими частями дизайна (ff1 и ff3). Это может привести к проблемам, связанным с задержками и синхронизацией сигналов, проходящих через реконфигурируемый модуль.
2. **Второй вариант (справа сверху, "Better")**:
   - В этом варианте весь реконфигурируемый модуль (RM), включая все его компоненты (ff1, ff2, ff3), находится внутри одного блока. Это лучше, чем первый вариант, так как все статические компоненты и реконфигурируемый модуль сгруппированы вместе, что минимизирует проблемы с задержками.
3. **Третий вариант (справа снизу, "Best")**:
   - Этот вариант считается наилучшим. В данном случае все статические компоненты (ff1, ff2, ff3) и реконфигурируемый модуль (RM) находятся в одном блоке, но при этом статические компоненты находятся на границе блока. Это обеспечивает минимальные задержки сигналов и лучшую синхронизацию, так как статические компоненты находятся на границе реконфигурируемого модуля.

Рекомендации для оптимального использования частичной реконфигурации:
- Избегайте размещения реконфигурируемого модуля между статическими компонентами.
- Старайтесь размещать все компоненты реконфигурируемого модуля в одном блоке.
- Размещайте статические компоненты на границе реконфигурируемого модуля для минимизации задержек и улучшения синхронизации сигналов.

![](../attachments/Pasted%20image%2020241217181247.png)

1. **Использование логики разделения (Decoupling Logic)**:
   - Логика разделения необходима для изоляции реконфигурируемого модуля (RM) от статической части схемы во время процесса реконфигурации. Это помогает предотвратить некорректное поведение системы из-за промежуточных состояний сигналов.
2. **Контрольная логика PR (PR Control Logic)**:
   - Контрольная логика PR управляет процессом реконфигурации, включая сброс RM (RM Reset) и управление включением RM (RM CE). 
   - Во время реконфигурации контрольная логика должна обеспечить корректное отключение и включение RM, а также его сброс для начала работы с корректными начальными условиями.
3. **Буферизация статических сигналов (Static Buffer)**:
   - Буферизация статических сигналов или управление их включением (CE) необходимо для поддержания стабильности системы во время реконфигурации. Буферизация помогает сохранить текущее состояние сигналов, предотвращая некорректное поведение статической части схемы.
4. **Сброс и включение RM (RM Reset и RM CE)**:
   - После завершения процесса реконфигурации необходимо сбросить RM и включить его для начала нормальной работы. Это помогает избежать некорректного состояния и обеспечивает корректное начало работы реконфигурируемого модуля.

## DFX, маршрут проектирования.
Dynamic Function eXchange (DFX) — это мощная технология, используемая в программируемых логических интегральных схемах (ПЛИС или FPGA), которая позволяет изменять часть аппаратного обеспечения в реальном времени, не влияя на работу остальной части устройства. Эта технология обеспечивает уникальные возможности для оптимизации производительности, адаптации функционала и улучшения энергоэффективности систем на кристалле.

### Маршрут проектирования DFX
Процесс проектирования динамически реконфигурируемых FPGA (Field-Programmable Gate Array) включает в себя множество этапов

#### 1. Определение реконфигурируемых разделов (Reconfigurable Partitions, RP)
На этом этапе происходит выделение областей в иерархии проекта, которые будут подвергаться динамической реконфигурации. Эти области, или разделы, должны быть определены таким образом, чтобы минимизировать взаимодействие с остальной частью схемы и упростить процесс замены модулей во время работы.

#### 2. Создание набора реконфигурируемых модулей (Reconfigurable Modules, RM)
Для каждого реконфигурируемого раздела разрабатывается несколько модулей, которые могут заменять друг друга в ходе выполнения. Эти модули должны быть совместимы по интерфейсам и размерам с разделом, в который они вставляются, чтобы обеспечить корректную динамическую замену без перерыва работы устройства.

#### 3. Запуск синтеза на верхнем и уровне модулей
На этом этапе осуществляется синтез как для всей схемы, так и для отдельных модулей. Это позволяет оптимизировать каждый модуль в отдельности и упрощает процедуру обновления модулей, поскольку для каждого из них уже будет выполнен синтез.

#### 4. Формирование связанных наборов реализаций
Создаются наборы реализации для каждого раздела и модуля, которые включают в себя все необходимые данные для обеспечения совместимости между динамически заменяемыми компонентами. Это критически важно для обеспечения того, чтобы все модули могли корректно функционировать в рамках одного раздела.

#### 5. Управление зависимостями
Этот этап включает контроль за всеми зависимостями проекта, включая исходные файлы, ограничения, настройки и параметры синтеза. Управление зависимостями гарантирует, что изменения в одной части проекта не приведут к непредвиденным проблемам в других частях.

#### 6. Проверка правил и результатов (DRC)
Выполняется проверка проекта на соответствие всем правилам проектирования. Это включает проверку на соответствие электрических, временных и других параметров, чтобы убедиться, что динамическая реконфигурация не нарушит работы устройства.

#### 7. Верификация конфигураций
На этом этапе проводится тестирование всех возможных комбинаций статической и динамической логики. Это позволяет гарантировать, что любые изменения в конфигурации модулей будут корректно работать во всех предусмотренных сценариях использования.

#### 8. Генерация полных и частичных битстримов
На данном этапе происходит создание наборов полных и частичных битстримов, которые используются для загрузки в FPGA. Полные битстримы нужны для начальной загрузки устройства, в то время как частичные битстримы позволяют динамически реконфигурировать отдельные разделы без необходимости перезагружать всю FPGA.

- **Полные битстримы** содержат всю конфигурацию FPGA и используются при первичной загрузке или когда требуется полный рестарт устройства.
- **Частичные битстримы** предназначены для загрузки в реконфигурируемые разделы (RP) и могут быть использованы для изменения функциональности этих разделов на лету, без воздействия на работу статической части схемы.

Этот процесс требует тщательного планирования и тестирования, чтобы убедиться, что загрузка частичных битстримов не приведёт к ошибкам в работе других частей FPGA.

## IP-ядра DFX, описание ядер
1. DFX Controller — это центральное IP-ядро, которое управляет процессом динамической реконфигурации. Оно служит интерфейсом между логикой приложения и аппаратными механизмами, которые выполняют загрузку новых битстримов в реконфигурируемые разделы FPGA.
- Основные функции DFX Controller:
  - Инициация реконфигурации: Запускает процесс загрузки частичного битстрима в указанный реконфигурируемый раздел.
  - Управление зависимостями: Контролирует зависимости между различными реконфигурируемыми модулями, обеспечивая корректную загрузку и функционирование.
  - Синхронизация: Обеспечивает синхронную работу статической и динамической частей FPGA, координируя переключение между различными конфигурациями.
2. DFX Decoupler — это IP-ядро, предназначенное для временной "отсечки" или изоляции реконфигурируемого раздела от остальной части схемы во время процесса реконфигурации. Это критически важно для предотвращения передачи некорректных данных или состояний, которые могут нарушить работу устройства.
- Основные функции DFX Decoupler:
  - Изоляция сигналов: Блокирует передачу сигналов между реконфигурируемым разделом и статической частью FPGA во время реконфигурации, предотвращая возможные ошибки и конфликты.
  - Управление состоянием: Поддерживает сохранение состояния интерфейсов до начала реконфигурации и восстановление после завершения, обеспечивая плавное переключение между модулями.
3. DFX Bitstream Monitor — это IP-ядро, которое обеспечивает мониторинг и проверку процесса загрузки битстримов. Оно позволяет отслеживать успешность операций реконфигурации и предоставляет информацию о статусе для системы управления.
- Основные функции DFX Bitstream Monitor:
  - Мониторинг загрузки: Отслеживает процесс загрузки частичных битстримов и генерирует сигналы о завершении или об ошибках.
  - Логирование: Собирает данные о процессе реконфигурации, включая время загрузки и возникшие ошибки, для анализа и отладки.
  - Валидация данных: Проверяет целостность и корректность загружаемых битстримов перед началом их исполнения.
4. DFX Shutdown Manager — это ядро, которое управляет безопасным выключением и перезагрузкой реконфигурируемых разделов. Это IP-ядро необходимо для предотвращения повреждения данных и обеспечения целостности системы при изменении конфигурации.
- Основные функции DFX Shutdown Manager:
  - Управление питанием: Контролирует подачу питания на реконфигурируемые разделы, обеспечивая их безопасное отключение и включение.
  - Менеджмент состояния: Управляет сохранением и восстановлением внутреннего состояния модулей при выключении, гарантируя корректное возобновление работы после реконфигурации.
  - Синхронизация процессов: Координирует порядок действий при остановке и запуске разделов, минимизируя риск возникновения ошибок в работе системы.

### DFX Controller
![](../attachments/Pasted%20image%2020241217181259.png)

1. Контроллер DFX: Центральный элемент для динамической реконфигурации, отвечает за загрузку частичных битстримов в FPGA. Взаимодействует с BPI FLASH для доступа к данным конфигурации.
2. Small FPGA: Запускает основное приложение, которое инициирует контроллер DFX для запуска процессов реконфигурации.
3. Large FPGA: Содержит ICAP (Internal Configuration Access Port), используемый для применения частичных битстримов. Содержит виртуальные сокеты (0 до 3), где могут динамически загружаться различные конфигурации.
4. Virtual Sockets: Это реконфигурируемые области в большой FPGA. Каждый сокет может быть настроен с различными функциями по мере необходимости.
5. Триггеры: Инициируются приложением, работающим на маленькой FPGA, и сообщают контроллеру DFX о начале процесса реконфигурации.

### DFX Decoupler
![](../attachments/Pasted%20image%2020241217181307.png)

1. AXI4-Stream Master (DATA): Отправляет данные в переопределяемую часть.
2. AXI4-Stream Slave (RESULT): Получает данные из переопределяемой части.
3. Мультиплексоры: Используются для управления сигналами в обоих направлениях. Позволяют переключать сигналы между активными (tvalid, tready) и неактивными состояниями (в данном случае — 0), чтобы изолировать переопределяемую часть от статической части.
4. Сигналы управления: s_DATA_tdata, s_DATA_tvalid, s_DATA_tready для передачи данных к статической части. s_RESULT_tdata, s_RESULT_tvalid, s_RESULT_tready для приема данных от статической части.

Данные и управляющие сигналы от AXI4-Stream Master поступают на мультиплексоры. Если система активна, мультиплексоры передают сигналы далее в статическую часть. Если система в режиме изоляции, мультиплексоры переключаются на передачу неактивного состояния (0), изолируя переопределяемую часть.

### DFX Bitstream Monitor
![](../attachments/Pasted%20image%2020241217181313.png)

1. S_AXI: Интерфейс, который используется для коммуникации с другими частями системы через AXI (Advanced eXtensible Interface).
2. clk: Тактовый сигнал, синхронизирующий работу модуля.
3. resetn: Активный низкий сигнал сброса, который инициализирует состояние системы.
4. arm: Сигнал, который активирует или вооружает монитор для начала отслеживания.
5. one_shot: Сигнал, инициирующий одноразовое действие или событие.
6. ref_sp_id_i[31:0]: Входной идентификатор, возможно, связанный с определенной конфигурацией или состоянием.
7. protocol_abort: Сигнал, используемый для прерывания текущего протокола или операции.
8. protocol_resetn: Активный низкий сигнал сброса протокола.
9. LIVE_INFO и HISTORIC_INFO: Выходы, которые предоставляют текущую и историческую информацию о состоянии битстрима.
10. armed: Выходной сигнал, который указывает, что монитор активирован.
11. armed_oneshot: Выход, показывающий, что одноразовое событие было инициировано.
12. ref_sp_id_o[31:0]: Выходной идентификатор, возможно, отражающий текущую конфигурацию или состояние.

DFX Bitstream Monitor работает следующим образом:

1. **Инициализация**: При подаче тактового сигнала и снятии сигнала сброса (resetn), монитор готовится к работе.
2. **Вооружение (Arming)**: Через сигнал **arm** монитор активируется и готовится к отслеживанию изменений в битстриме. Сигнал **armed** указывает, что монитор активирован.
3. **Отслеживание событий**: 
   - Сигнал **one_shot** может использоваться для инициирования одноразового события, такого как загрузка новой конфигурации.
   - Идентификатор конфигурации **ref_sp_id_i[31:0]** передается на вход для отслеживания конкретной конфигурации.
4. **Мониторинг протокола**: 
   - Сигналы **protocol_abort** и **protocol_resetn** управляют состоянием текущих операций, позволяя при необходимости прерывать или сбрасывать процесс.
5. **Информация о состоянии**: 
   - **LIVE_INFO** и **HISTORIC_INFO** предоставляют информацию о текущем и предыдущих состояниях системы.
   - Выходы **armed** и **armed_oneshot** показывают активность и одноразовые события.
6. **Выходная информация**: 
   - Идентификатор состояния **ref_sp_id_o[31:0]** отражает текущую конфигурацию или состояние системы.

### DFX Shutdown Manager
![](../attachments/Pasted%20image%2020241217181322.png)

1. S_AXI: Интерфейс для соединений slave AXI, используемый для конфигурации и управления.
2. clk: Тактовый сигнал для синхронизации.
3. resetn: Активный низкий сигнал сброса для инициализации системы.
4. request_shutdown: Сигнал для запроса отключения.
5. M_AXI: Интерфейс для соединений master AXI, используемый для связи с другими компонентами.
6. shutdown_requested: Указывает, что был запрошен процесс отключения.
7. in_shutdown: Указывает, что система находится в процессе отключения.
8. irq: Общий сигнал запроса прерывания.
9. wr_irq: Сигнал запроса прерывания на запись.
10. rd_irq: Сигнал запроса прерывания на чтение.
11. wr_in_shutdown: Указывает на операцию записи во время отключения.
12. rd_in_shutdown: Указывает на операцию чтения во время отключения.

Когда требуется отключение, активируется сигнал request_shutdown. Выход shutdown_requested сообщает об этом запросе подключённым системам через интерфейс M_AXI. Система переходит в последовательность отключения, что указывается сигналом in_shutdown.

Во время отключения могут срабатывать специфические прерывания на чтение или запись (wr_irq, rd_irq), во время процесса отключения могут возникнуть ситуации, когда необходимо обработать завершение текущих операций чтения или записи данных. Специфические прерывания на запись (wr_irq) и чтение (rd_irq) сигнализируют о том, что такие операции происходят и требуют внимания, чтобы корректно завершить их перед полным отключением системы. Это помогает избежать потери данных и обеспечивает корректное завершение всех операций перед выключением.
