# 11. Методы и инструменты верификации Часть 1.

## Типы верификации
* **Функциональная верификация:** проверка соответствия системы заявленным функциям из технического задания.
* **Формальная верификация:** доказательство корректности системы математическими и логическими методами.
* **Статический анализ кода:** проверка корректности конструкций языка описания аппаратуры.
* **Физическая верификация:** проверка корректности физического представления системы (напр., соответствие нормам производства).
* **Прототипирование:** проверка в реальных условиях с использованием программируемых логических интегральных схем (ПЛИС).

Основной фокус лекции — **функциональная верификация** и её реализация с помощью языка SystemVerilog и методологии UVM (Universal Verification Methodology).  Лектор объясняет:

* **Метрики оценки результатов:** покрытие функциональности, кода и утверждений.
* **Инструменты:** SystemVerilog, UVM.
* **Особенности SystemVerilog:** расширение языка Verilog для верификации, объектно-ориентированный подход, конструкции для описания тестов.
* **Развитие методологий верификации:** от OVM к UVM, стандартизация UVM (IEEE 1800.2-2017).

### Функциональная верификация
Процесс проверки соответствия разрабатываемой схемы или системы заявленным в техническом задании функциям.  Она является одним из ключевых этапов проектирования аппаратного обеспечения.

**Цель:**  Главная цель функциональной верификации – убедиться, что система выполняет все требуемые функции корректно, согласно спецификации.

**Тесты:** Для достижения этой цели используются различные типы тестов, которые можно разделить на три основные категории:

* **Позитивные тесты:** Проверяют корректную работу системы при подаче допустимых входных данных.  Ожидается, что система выдаст правильный результат и не возникнут ошибки.
* **Негативные тесты:**  Проверяют поведение системы при подаче недопустимых или ошибочных входных данных. Цель – убедиться, что система корректно обрабатывает ошибки, не выходит из строя и, по возможности, восстанавливается после сбоя.
* **Тестирование случайных ситуаций:** Проверка поведения системы в нестандартных или непредвиденных ситуациях.  Сюда могут входить тесты на нарушение порядка следования данных, изменение формата данных, воздействие внешних факторов (например, электромагнитные помехи), внесение ошибок в ход работы системы и т.д.

**Разнообразие тестов:**  Лектор подчеркивает, что набор тестов очень разнообразен и зависит от специфики проверяемой системы и её функций.  Чем сложнее система, тем больше потребуется тестов для обеспечения полного покрытия всех возможных сценариев работы.

**Отличие от формальной верификации:**  Важный момент, который выделяет лектор, – это различие между функциональной и формальной верификацией.  Хотя оба типа верификации направлены на проверку корректности системы, они используют разные подходы. Функциональная верификация основана на тестировании, а формальная – на математическом доказательстве.

**Инструменты и методологии:** В лекции подробно рассматриваются инструменты и методологии, используемые для проведения функциональной верификации, такие как SystemVerilog и UVM (Universal Verification Methodology).  Эти инструменты предоставляют мощные средства для создания и выполнения тестов, а также для анализа результатов верификации.  Особое внимание уделяется:

* **SystemVerilog:**  Расширение языка Verilog, специально разработанное для верификации.  Он предоставляет конструкции для описания тестовой логики, генерации тестовых данных, создания тестового окружения и анализа результатов.
* **UVM:**  Стандартизированная методология, которая определяет структуру и компоненты тестового окружения.  UVM упрощает создание сложных тестовых сценариев, повторное использование кода и взаимодействие между различными компонентами тестового окружения.

В целом, функциональная верификация – это важный этап проектирования аппаратного обеспечения, который позволяет убедиться в корректной работе системы перед её физической реализацией.  Использование современных инструментов и методологий, таких как SystemVerilog и UVM, значительно повышает эффективность и полноту функциональной верификации.

* **Структура тестового окружения в UVM:** компоненты (environment, sequencer, driver, monitor, scoreboard, agent), транзакционная модель, уровни абстракции (транзакции и сигналы).
* **Классовая структура UVM:** базовые классы (uvm_component, uvm_transaction, uvm_sequence_item, uvm_sequence, uvm_driver, uvm_monitor, uvm_scoreboard, uvm_agent, uvm_factory).

Лектор также затрагивает тему покрытия кода и примеры реализации функциональной верификации на SystemVerilog.  В конце лекции упоминается важность использования UVM в индустрии и её преимущества для больших проектов.

### Формальная верификация
В лекции формальная верификация противопоставляется функциональной. Если функциональная верификация основана на запуске тестов и проверке результатов, то формальная верификация использует математические и логические методы для *доказательства* корректности работы системы.

**Цель:**  Основная цель формальной верификации — убедиться в корректности работы системы, используя строгие математические доказательства, а не эмпирическое тестирование.  Это позволяет выявить ошибки, которые сложно или невозможно обнаружить с помощью тестирования.

**Методы:**  Вместо тестов формальная верификация использует формальные модели системы и математические методы для анализа её поведения.  Это может включать в себя:

* **Проверку свойств (model checking):**  Проверка, удовлетворяет ли модель системы заданным свойствам (например, отсутствие тупиковых ситуаций, соблюдение временных ограничений).
* **Доказательство теорем:**  Математическое доказательство корректности алгоритмов и логики системы.
* **Эквивалентность моделей:** Проверка, что разные модели системы (например, модель высокого уровня и модель на уровне вентилей) эквивалентны друг другу.  Это особенно важно при переходе от одного уровня абстракции к другому в процессе проектирования.

**Преимущества:**

* **Поиск трудновоспроизводимых ошибок:**  Формальная верификация может найти ошибки, которые сложно воспроизвести при тестировании, например, ошибки, возникающие только при определенных комбинациях входных данных или в определенные моменты времени.
* **Полный охват:** В идеале, формальная верификация может обеспечить полный охват всех возможных состояний системы, что невозможно достичь при тестировании, особенно для сложных систем.

**Ограничения:**

* **Сложность:**  Формальная верификация требует создания формальных моделей системы, что может быть сложной задачей, особенно для больших и сложных систем.
* **Вычислительные ресурсы:**  Проверка свойств и доказательство теорем могут требовать значительных вычислительных ресурсов, особенно для сложных систем.
* **Размер и сложность:** Применимость формальной верификации ограничена размером и сложностью системы.  Для очень больших и сложных систем формальная верификация может быть непрактичной.

**Применение:**  Формальная верификация часто используется для проверки критически важных частей системы, где цена ошибки очень высока (например, в аэрокосмической промышленности, медицине).

В лекции подчеркивается, что формальная верификация не заменяет полностью функциональную, а дополняет её.  Оба типа верификации важны для обеспечения корректности и надежности разрабатываемой системы.

### Статическая верификация
Ппроверка корректности используемых конструкций языка описания аппаратуры (HDL) *без* запуска симуляции или синтеза.  По сути, это автоматизированный анализ исходного кода на наличие потенциальных ошибок и проблем.

**Цель:** Основная цель статической верификации — выявить ошибки на ранних этапах проектирования, до запуска симуляции или синтеза.  Это позволяет сэкономить время и ресурсы, так как исправление ошибок на более поздних этапах проектирования обходится значительно дороже.

**Методы:** Статическая верификация использует различные методы анализа кода, такие как:

* **Синтаксический анализ:** Проверка кода на соответствие правилам синтаксиса языка HDL.
* **Семантический анализ:**  Проверка кода на соответствие смысловым правилам языка HDL.
* **Анализ потока данных:**  Анализ потока данных в коде для выявления потенциальных проблем, таких как неинициализированные переменные, деление на ноль, переполнение.
* **Анализ стиля кода:** Проверка кода на соответствие принятым стандартам стиля кодирования.  Это помогает улучшить читаемость и поддерживаемость кода.

**Инструменты:**  В лекции упоминается, что инструменты статической верификации (статические анализаторы кода) встроены практически во все современные системы автоматизированного проектирования (САПР).  Эти инструменты автоматически проверяют код на наличие потенциальных ошибок и выдают предупреждения или сообщения об ошибках.

**Преимущества:**

* **Раннее обнаружение ошибок:**  Статическая верификация позволяет обнаружить ошибки на ранних этапах проектирования, что упрощает и удешевляет их исправление.
* **Автоматизация:**  Статическая верификация выполняется автоматически, что экономит время и усилия разработчиков.
* **Покрытие:**  Статическая верификация может охватить весь исходный код проекта, что сложно достичь при тестировании.

**Ограничения:**  Статическая верификация не может обнаружить все типы ошибок.  Например, она не может проверить корректность логики системы или её соответствие требованиям.  Для этого необходимы другие виды верификации, такие как функциональная или формальная верификация.

**Вывод:** Статическая верификация — важный инструмент для повышения качества кода и раннего обнаружения ошибок.  Она является неотъемлемой частью современного процесса проектирования аппаратного обеспечения.  Хотя статическая верификация проводится в последнюю очередь, лектор подчёркивает её важность, особенно на начальных этапах проектирования.

### Физическая верификация
Этап проверки корректности *физического представления* системы.  В отличие от функциональной верификации, которая проверяет поведение системы, физическая верификация фокусируется на том, как система будет реализована физически.  В контексте проектирования интегральных схем (ИС) это означает проверку топологии чипа.

**Цель:** Главная цель физической верификации – убедиться, что физическая реализация системы соответствует технологическим нормам, проектным правилам и исходной логической схеме.  Это гарантирует, что чип можно будет изготовить без проблем и он будет работать корректно.

**Основные проверки:** В лекции выделяются несколько ключевых проверок, выполняемых в рамках физической верификации:

* **DRC (Design Rule Check - проверка проектных правил):** Это основной тип проверки в физической верификации.  DRC проверяет соответствие топологии чипа технологическим ограничениям, установленным фабрикой-изготовителем.  Эти ограничения включают в себя минимальные размеры элементов, минимальные расстояния между элементами, правила соединения слоев и т.д.  Соблюдение этих правил критически важно для успешного изготовления чипа.
* **LVS (Layout Versus Schematic - сравнение топологии со схемой):**  LVS проверяет соответствие физической топологии чипа исходной логической схеме.  Цель – убедиться, что топология правильно реализует логику схемы, и нет ошибок в соединениях, размещении элементов и т.д.  LVS обычно включает два этапа: извлечение схемы из топологии и сравнение извлеченной схемы с исходной.
* **ERC (Electrical Rule Check - проверка электрических правил):**  ERC проверяет соответствие электрических характеристик схемы заданным спецификациям.  Это может включать в себя проверку целостности питания, проверку на наличие коротких замыканий, проверку соответствия токов и напряжений допустимым значениям и т.д.  ERC помогает выявить потенциальные проблемы с электропитанием и целостностью сигналов.

**Типичные ошибки:** Лектор приводит примеры типичных ошибок, которые могут быть выявлены в процессе физической верификации:

* **Ошибки соединений:** Неправильные соединения между элементами, несоответствие номеров контактов и т.д.
* **Нарушение DRC:**  Нарушение минимальных размеров, расстояний и других проектных правил.
* **Несоответствие LVS:**  Различия между топологией и схемой.
* **Проблемы с электропитанием:**  Короткие замыкания, неправильное подключение питания, превышение допустимых токов и напряжений.
* **Непреднамеренные паразитные элементы:** Например, образование паразитной индуктивности или емкости из-за особенностей топологии.

**Кто выполняет:**  Физическую верификацию обычно выполняют инженеры по физическому проектированию ИС в специализированных дизайн-центрах, часто работающих при заводах-изготовителях.  Они используют автоматизированные инструменты для проведения проверок и анализа результатов.

**Важность:**  Физическая верификация – критически важный этап проектирования ИС, который позволяет убедиться в том, что чип можно будет изготовить и он будет работать корректно.  Без тщательной физической верификации высока вероятность дорогостоящих ошибок и переделок на этапе производства.

### Прототипирование
Этап, предшествующий этапу физической реализации (например, производству микросхемы).  Он позволяет проверить проект в условиях, приближенных к реальным, и убедиться в корректности его работы до запуска в производство.

**Цель:** Основная цель прототипирования — проверить функциональность системы в реальном времени и выявить потенциальные проблемы, связанные с взаимодействием с физическим миром. Это дает возможность обнаружить и исправить ошибки до того, как они приведут к дорогостоящим переделкам на этапе производства.

**Инструменты:**  Основным инструментом прототипирования, упомянутым в лекции, являются программируемые логические интегральные схемы (ПЛИС). ПЛИС позволяют реализовать логику проектируемой системы на программируемой аппаратной платформе, что обеспечивает высокую скорость работы и возможность взаимодействия с реальными физическими сигналами.

**Преимущества:**

* **Проверка в реальном времени:** Прототипирование на ПЛИС позволяет проверить работу системы в реальном времени, с учетом задержек и других физических эффектов, которые сложно или невозможно учесть при моделировании.
* **Взаимодействие с физическим миром:** ПЛИС можно подключить к реальным устройствам и датчикам, что позволяет проверить взаимодействие системы с физическим миром.
* **Выявление скрытых проблем:** Прототипирование может выявить скрытые проблемы, которые не были обнаружены на этапах функциональной или формальной верификации.

**Важность:** Лектор подчеркивает важность прототипирования, особенно перед передачей проекта на физическую реализацию.  Он отмечает, что часто разработчики обращаются к производителям с не полностью проверенными проектами, что приводит к проблемам и задержкам. Прототипирование позволяет избежать подобных ситуаций и убедиться в корректности работы системы перед запуском в производство.  Это особенно важно для сложных проектов, где цена ошибки очень высока.

**Пример:** Лектор приводит пример ситуации, когда разработчики приходят с RTL-кодом (Register-Transfer Level) и просят создать на его основе схему. Он указывает, что это неправильный подход, и необходимо предварительно провести прототипирование и верификацию проекта, чтобы убедиться в его корректности.

В заключении лектор подчёркивает, что прототипирование и тестирование на ПЛИС – один из важнейших этапов в процессе разработки аппаратного обеспечения, позволяющий снизить риски и повысить качество конечного продукта.

## Метрики функциональной верификации
В лекции обсуждаются три основные метрики для оценки результатов функциональной верификации: покрытие функциональности, покрытие кода и покрытие утверждений.  Они помогают оценить полноту и эффективность проведенной верификации.

**1. Функциональное покрытие (Functional Coverage):**
* **Что измеряет:** Эта метрика показывает, насколько полно были протестированы *функции* устройства, описанные в спецификации.  Она отвечает на вопрос: все ли функции были проверены, и были ли они проверены при различных условиях и комбинациях входных данных?
* **Как используется:**  Для оценки покрытия функциональности разработчики определяют набор функциональных точек (features), которые необходимо покрыть тестами.  Затем, во время симуляции, отслеживается, какие функциональные точки были активированы.  Цель – достичь 100% покрытия всех заданных функциональных точек.
* **Пример:** Если функция устройства – это сложение двух чисел, то функциональное покрытие может отслеживать, были ли протестированы сложение положительных чисел, отрицательных чисел, нуля, чисел с разными знаками, чисел на границах диапазона и т.д.

**2. Покрытие кода (Code Coverage):**
* **Что измеряет:**  Эта метрика показывает, какая часть *кода* была выполнена во время симуляции.  Она помогает выявить "мертвый" код, который никогда не выполняется, и код, который был протестирован недостаточно.
* **Типы покрытия кода:** Существуют различные типы покрытия кода, например:
    * **Покрытие строк (Line Coverage):**  Процент выполненных строк кода.
    * **Покрытие ветвей (Branch Coverage):** Процент выполненных ветвей в условных операторах (if-else, case).
    * **Покрытие условий (Condition Coverage):**  Процент выполненных условий в логических выражениях.
    * **Покрытие выражений (Expression Coverage):** Процент выполненных логических выражений.
    * **Покрытие переходов (Toggle Coverage):** Процент переключений сигналов с 0 на 1 и с 1 на 0.
* **Как используется:**  Инструменты симуляции автоматически собирают данные о покрытии кода.  Разработчики анализируют эти данные и добавляют новые тесты, чтобы увеличить покрытие кода и протестировать не покрытые участки.

**3. Покрытие утверждений (Assertion Coverage):**
* **Что измеряет:**  Эта метрика показывает, какая часть *утверждений* (assertions) была проверена во время симуляции. Утверждения – это логические выражения, которые проверяют определенные условия в коде.  Они используются для проверки корректности работы системы.
* **Как используется:**  Подобно функциональному покрытию, разработчики определяют набор утверждений, которые необходимо проверить.  Во время симуляции отслеживается, какие утверждения были выполнены и какие из них привели к ошибкам.  Цель – достичь 100% покрытия всех заданных утверждений и убедиться, что ни одно из них не привело к ошибке.

**Взаимосвязь:** Эти три метрики взаимосвязаны и дополняют друг друга.  Высокое покрытие кода не гарантирует высокое покрытие функциональности, и наоборот.  Покрытие утверждений помогает проверить корректность работы системы на более глубоком уровне, чем покрытие кода или функциональности.

**Цель:**  В идеале, разработчики стремятся достичь 100% покрытия по всем трем метрикам.  Однако на практике это не всегда возможно или целесообразно.  Важнее всего сосредоточиться на наиболее критичных функциях и участках кода.
### Покрытие кода
Лекция затрагивает тему покрытия кода в контексте функциональной верификации с использованием SystemVerilog.  Хотя детали реализации не раскрываются полностью, лектор дает общее представление о принципах и целях использования покрытия, а также приводит примеры использования конструкций SystemVerilog для верификации.

* **Цель:** Покрытие кода (code coverage) используется для измерения, какая часть кода DUT (Device Under Test) была активирована во время симуляции тестов.  Это важная метрика, которая помогает оценить полноту верификации и выявить потенциально непроверенные участки кода.  Высокое покрытие кода не гарантирует отсутствие ошибок, но низкое покрытие сигнализирует о том, что некоторые части кода не были протестированы и могут содержать скрытые ошибки.
* **Типы покрытия:**  Существуют разные типы покрытия кода, например, покрытие строк (line coverage), покрытие ветвей (branch coverage), покрытие условий (condition coverage) и т.д.  Каждый тип покрытия дает информацию о разных аспектах выполнения кода.
* **Использование в SystemVerilog:** SystemVerilog предоставляет встроенные механизмы для сбора данных о покрытии кода во время симуляции.  Эти данные затем анализируются для оценки полноты верификации.

**Примеры реализации функциональной верификации на SystemVerilog:**

Лектор приводит примеры использования SystemVerilog для создания тестовых сценариев и проверки функциональности.  Хотя примеры не представлены в виде законченного кода, они демонстрируют некоторые ключевые аспекты:

* **Утверждения (Assertions):**  Утверждения используются для проверки корректности работы системы во время симуляции.  В SystemVerilog есть мощные конструкции для создания утверждений, которые позволяют проверять различные условия и генерировать сообщения об ошибках при нарушении этих условий.  Пример: `assert (a == b)` проверит, равны ли значения переменных `a` и `b`.
* **Покрытие (Coverage):**  SystemVerilog позволяет собирать данные о покрытии кода и функциональном покрытии.  Это помогает оценить полноту верификации и выявить непроверенные участки кода или функциональности.  Лектор приводит примеры использования `covergroup` и `coverpoint` для определения точек покрытия и сбора статистики.
* **Рандомизация (Randomization):**  SystemVerilog поддерживает рандомизацию тестовых данных, что позволяет генерировать разнообразные входные воздействия и повысить эффективность верификации.  Лектор демонстрирует использование `rand` для объявления случайных переменных и `constraint` для задания ограничений на значения этих переменных.
* **Классы и объекты:**  SystemVerilog поддерживает объектно-ориентированное программирование (ООП), что позволяет создавать более структурированный и повторно используемый код для верификации.  Лектор показывает примеры создания классов и объектов, а также использования наследования и полиморфизма.

**Связь с UVM:**  Все эти конструкции SystemVerilog используются в рамках методологии UVM для создания тестовых окружений.  UVM предоставляет стандартную структуру и набор классов, которые упрощают создание и управление тестовыми сценариями, генерацию тестовых данных, сбор данных о покрытии и анализ результатов верификации.

В целом, лекция дает общее представление о том, как SystemVerilog используется для функциональной верификации, и подчеркивает важность покрытия кода как метрики для оценки полноты верификации. 
## Инструменты проведения аппаратной функциональной верификации. 
### SystemVerilog Assertions
Лекция позиционирует SystemVerilog и UVM как ключевые инструменты для современной функциональной верификации.  Давайте разберем каждый из них подробнее:

**SystemVerilog:**
* **Что это:** SystemVerilog — это расширение языка Verilog, специально разработанное для верификации аппаратного обеспечения. Он добавляет множество новых возможностей, которые упрощают создание сложных тестовых сценариев и тестовых окружений.
* **Ключевые особенности для верификации:**
    * **Объектно-ориентированное программирование (ООП):**  SystemVerilog поддерживает ООП, что позволяет создавать более структурированный и повторно используемый код для верификации.  Классы, объекты, наследование, полиморфизм – все эти концепции ООП доступны в SystemVerilog.
    * **Специализированные типы данных:**  SystemVerilog предоставляет новые типы данных, которые удобны для верификации, например, динамические массивы, очереди, ассоциативные массивы и др.
    * **Усовершенствованные конструкции для управления потоком выполнения:**  SystemVerilog предлагает новые конструкции для управления параллельными процессами, синхронизации и коммуникации между ними.
    * **Утверждения (Assertions):**  SystemVerilog позволяет встраивать утверждения непосредственно в код, что упрощает проверку корректности работы системы.
    * **Покрытие кода и функциональное покрытие:** SystemVerilog предоставляет средства для сбора данных о покрытии кода и функциональном покрытии.
* **Преимущества:** SystemVerilog значительно упрощает создание сложных тестовых сценариев и тестовых окружений, повышает производительность верификации и улучшает качество кода.

### UVM (Universal Verification Methodology)
* **Что это:** UVM — это методология верификации, основанная на SystemVerilog.  Она предоставляет стандартизированную библиотеку классов и набор правил для создания тестовых окружений.
* **Ключевые концепции:**
    * **Структура тестового окружения:** UVM определяет стандартную структуру тестового окружения, состоящую из компонентов, таких как driver, monitor, sequencer, agent, scoreboard и environment.  Эта структура обеспечивает модульность и повторное использование кода.
    * **Транзакции:** UVM использует концепцию транзакций для представления данных, которыми обмениваются компоненты тестового окружения.
    * **Последовательности (Sequences):** UVM позволяет создавать последовательности транзакций для моделирования различных сценариев работы системы.
    * **Фазы симуляции (Simulation Phases):** UVM определяет набор стандартных фаз симуляции, которые обеспечивают упорядоченное выполнение тестовых сценариев.
    * **Конфигурация (Configuration):**  UVM предоставляет механизмы для конфигурации тестового окружения и его компонентов.
    * **Фабрика (Factory):**  UVM использует фабрику для создания объектов и компонентов. Это позволяет легко заменять компоненты тестового окружения без изменения кода.
* **Преимущества:** UVM упрощает создание, отладку и поддержку тестовых окружений, повышает повторное использование кода и улучшает взаимодействие между разработчиками.

**Взаимосвязь:** SystemVerilog – это язык, а UVM – это методология, основанная на этом языке.  UVM использует возможности SystemVerilog для реализации своих концепций и компонентов.  Вместе SystemVerilog и UVM предоставляют мощный и эффективный инструментарий для функциональной верификации аппаратного обеспечения.  Лектор делает акцент на важности использования UVM, особенно в крупных проектах, где требуется высокая степень организации и повторного использования кода.

### Особенности SystemVerilog
SystemVerilog содержит конструкции, позволяющие описывать тестовую логику с точки зрения соответствия некоторым утверждениям (assertions).

1. **Расширение Verilog для верификации:** SystemVerilog не является самостоятельным языком, а надстройкой над Verilog. Это означает, что весь синтаксис и функциональность Verilog доступны в SystemVerilog, но при этом добавлены новые конструкции, специально предназначенные для верификации.  Это обеспечивает обратную совместимость и позволяет постепенно внедрять SystemVerilog в существующие проекты.
2. **Несинтезируемые конструкции:** Большая часть конструкций SystemVerilog (более 80%, как указано в лекции) не предназначена для синтеза, то есть они не могут быть преобразованы в физическую схему.  Эти конструкции используются исключительно для верификации, например, для создания тестовых сценариев, генерации тестовых данных, моделирования тестового окружения и анализа результатов.  Это позволяет использовать высокоуровневые абстракции и конструкции, которые упрощают верификацию, но не могут быть реализованы в аппаратном обеспечении.
3. **Объектно-ориентированное программирование (ООП):**  SystemVerilog поддерживает парадигму ООП, что является одним из его главных преимуществ для верификации.  ООП позволяет создавать более структурированный, модульный и повторно используемый код.  Ключевые особенности ООП в SystemVerilog:
    * **Классы:**  Позволяют создавать шаблоны для объектов.
    * **Объекты:**  Экземпляры классов.
    * **Наследование:**  Позволяет создавать новые классы на основе существующих.
    * **Полиморфизм:**  Позволяет объектам разных классов реагировать по-разному на одни и те же методы.
    * **Инкапсуляция:**  Объединение данных и методов, работающих с этими данными, в единую структуру (класс).
4. **Расширенные типы данных:** SystemVerilog предоставляет новые типы данных, которые упрощают верификацию:
    * **Динамические массивы:**  Размер массива может изменяться во время выполнения.
    * **Очереди:**  Структуры данных, работающие по принципу FIFO (First-In, First-Out).
    * **Ассоциативные массивы:**  Массивы, в которых элементы индексируются не числами, а произвольными значениями (ключами).
5. **Усовершенствованные конструкции для управления тестовыми сценариями:**  SystemVerilog предлагает новые конструкции для создания и управления сложными тестовыми сценариями, включая:
    * **Randomization (рандомизация):**  Возможность генерации случайных тестовых данных.
    * **Constraints (ограничения):**  Возможность задавать ограничения на генерируемые случайные данные.
    * **Functional coverage (функциональное покрытие):**  Средства для отслеживания покрытия функциональности.

В целом, особенности SystemVerilog делают его мощным и гибким инструментом для верификации аппаратного обеспечения, позволяющим создавать сложные тестовые сценарии, моделировать тестовое окружение и эффективно анализировать результаты.  Он значительно расширяет возможности Verilog и упрощает процесс верификации, особенно для крупных и сложных проектов.

## Непосредственное утверждение
Непосредственное утверждение - процедурный оператор, которые используется для проверки заданного условия и сообщении о возникновении ошибки.

Синтаксис немедленного утверждения:
```c++
<метка>:
	assert ( <условие> )
		<действие при истине>;
	else
		<действие при лжи>;
```

## Функции для обработки ошибок
- `$fatal([уровень ошибки], <сообщение>, <аргументы>)`; фатальная ошибка, после вывода сообщения вызывается процедура `$finish`, останавливающая симуляцию
- `$error(<сообщение>, <аргументы>)`; фиксация ошибки без завершения симуляции
- `$warning(<сообщение>, <аргументы>)`; вывод предупреждения
- `$info(<сообщение>, <аргументы>)`; вывод дополнительной информации

## Параллельное утверждение
**Параллельное утверждение** - отдельный (параллельный) процесс, цель которого - проверять заданное свойство.

**Свойство (property)** - описывает допустимые последовательности сигналов. Описания последовательностей некоторым образом схожи с регулярными выражениями, в которых используются временные задержки или фронты тактовых сигналов.

```c++
property <имя_свойства>;
	<условие_поведения>;
endproperty

<метка>: assert property (<имя_свойства>)
		<действие при истине>;
	else
		<действие при лжи>;
```
## Поток утверждения
Последовательность выполнения отдельных событий в рамках свойства задаёт поток утверждения.

![](../../attachments/Pasted%20image%2020241203213244.png)
## Исходы для потока утверждений
- Свойство видит начало последовательности; запускается поток утверждения для проверки оставшейся части последовательности.
- Свойство не видит начал своей последовательности ( бессодержательный успех - vacuous success - попытка запустить поток утверждения была, но реального запуска не было ).
- Поток не увидел продолжения своей последовательности. Свойство нарушено: поток завершается.
- Поток утверждения увидел очередной шаг последовательности. Продолжается наблюдение за последующими шагами.
- Поток утверждения увидел последний шаг своей последовательности. Свойство выполнено, поток завершается.

## Примеры параллельных утверждений
```Verilog
property p1 (a, b, c);
	@(posedge clk) |-> (reset == 0)
	##1 (a == 5)
	##[2:3] (b == 2)
	[*1:2] ##1 (c == a / b);
endproperty

assert property ( p1 (a, b, c) )
	else
		$fatal("Ошибка");
```

Оператор импликации (|->) работает по следующей логике:
- поток утверждения запускается, только если определённое условие истинно. Существует две формы импликаций:
	- `i |=> j` если i истинно сейчас, то j должно быть истинно на **следующем** такте
	- `i |-> j` если i истинно сейчас, то j должно быть истинно **сейчас**
- Конструкция `##<n>` (оператор тактовой задержки) используется для указания количества тактов (n), по прошествии которых должно выполняться условие в рамках свойства.
- Конструкция `##[n:m]`, где n - минимальное число тактов, а m - максимальное, служит для задания диапазона числа тактов, через которое может быть выполнено условие в последовательности
- Конструкция `[*m:n]` указывает, что условие в последовательности должно повторяться в диапазоне времени от m до n тактов.

Другой пример
```Verilog
property p2 (a, b, c, d);
	@(posedge clk) |-> (a == 1) ##1 (b == 7) throughput ((c == 2) or (d == 3));
endproperty

assert property ( p2 (a, b, c, d) )
	else
		$fatal("Ошибка");
```

Для описания свойств также используются специальные операторы последовательности, определяющие порядок проверки последовательностей:
- `ог` - две последовательности начинаются на одном такте
- `throughout` - выражение в левой части должно сохранять значение истины на всем протяжении последовательности в правой части.

## Операторы, определяющие порядок проверки последовательностей
- `ог` - две последовательности начинаются на 1 такте.
- `and` - две последовательности начинаются на 1 такте.
- `intersect` - как `and`, но с дополнительным ограничением: последовательности должны завершиться в одно и то же время.
- `throughout` - выражение в левой части должно сохранять значение истины на всем протяжении последовательности в правой части.
- `within` - записывается в виде `$1 within $2`. Последовательность `$1` должна начаться не раньше `$2`, а закончиться не позже `$2`.
- `first_match` — если последовательности заданы с помощью перечисленных операторов и содержат повторения, число которых задано в форме диапазонов, может быть несколько совпадений в разные моменты времени; этот оператор сообщает о первом; все прочие отбрасываются.

. Coverpoint. Общие
сведения о UVM.

## Пример описания последовательности при помощи оператора sequence
Последовательности можно определять отдельно от свойств с помощью ключевого слова `sequence`
```verilog
sequence div_seq( a, b, c );
	##1 (a == 5)
	##2 (b == 2)
	##2 (c == a / b);
endsequence
```

```verilog
property p1( a, b, c );
	@(posedge clk)
		div_seq (a, b, c);
endproperty
```

```verilog
assert property ( p1 (a, b, c) )
	$display(“Результат корректен”);
else
	$display(“Результат некорректен”)
```

## Covergroup
Covergroup - это определяемый пользователем тип, который инкапсулирует спецификацию модели покрытия. Они могут быть определены один раз и создаваться несколько раз в разных местах с помощью функции `new`.

Covergroup может быть определена в пакете, модуле, программе, интерфейсе или классе и обычно содержит следующую информацию:
- Набор точек покрытия
- Перекрестное покрытие между точками покрытия
- Событие, определяющее время выборки covergroup
- Другие параметры настройки объекта покрытия

Covergroup может содержать одну или несколько точек покрытия. Coverpoint определяет выражение, которое требуется охватить. Вычисление выражения Coverpoint происходит при выборке Covergroup. Coverpoint SystemVerilog может быть дополнительно помечена двоеточием `:`.

## Общие сведения о UVM
### Развитие методологий верификации: от OVM к UVM
В лекции кратко описывается эволюция методологий верификации, приводящая к появлению UVM.  Этот путь показывает, как потребности индустрии в более эффективных и структурированных подходах к верификации привели к созданию современного стандарта.

* **Ранние подходы:**  До появления стандартизированных методологий, верификация часто выполнялась с использованием ad-hoc подходов, что приводило к созданию тестовых окружений, которые были сложно поддерживать, повторно использовать и масштабировать.  Отсутствовала единая структура и соглашение о наименованиях, что затрудняло совместную работу над проектами.

* **OVM (Open Verification Methodology):**  OVM стала одной из первых попыток стандартизировать методологию верификации. Она была разработана компанией Cadence и Mentor Graphics в 2008 году.  OVM представила ряд важных концепций, таких как:
    * **Объектно-ориентированный подход:** Использование классов и объектов для создания тестовых окружений.
    * **Стандартные компоненты:**  Определение стандартных компонентов тестового окружения, таких как driver, monitor и scoreboard.
    * **Транзакции:**  Использование транзакций для представления данных, которыми обмениваются компоненты.

* **Проблемы OVM:**  Несмотря на свои преимущества, OVM имела ряд недостатков:
    * **Зависимость от вендора:** OVM была тесно связана с инструментами Cadence и Mentor Graphics, что ограничивало её использование с другими инструментами.
    * **Отсутствие единого стандарта:**  Существовало две версии OVM: OVM 1.0 от Cadence и OVM 2.1.1 от Mentor Graphics.  Это создавало проблемы совместимости.

* **UVM (Universal Verification Methodology):**  UVM была разработана Accellera Systems Initiative как преемник OVM.  Основной целью UVM было создание единого, открытого и независимого от вендора стандарта для верификации.  UVM взяла лучшие идеи из OVM и устранила её недостатки.  Ключевые улучшения UVM:
    * **Стандартизация:**  UVM является стандартом IEEE 1800.2-2017, что гарантирует её совместимость с различными инструментами и методологиями.
    * **Независимость от вендора:**  UVM не привязана к конкретным инструментам, что позволяет использовать её с любыми симуляторами и САПР.
    * **Улучшенная архитектура:**  UVM имеет более чистую и понятную архитектуру, чем OVM.
    * **Расширенные возможности:**  UVM предоставляет дополнительные возможности, такие как фабрика (factory) для создания объектов, фазы симуляции (simulation phases) для управления выполнением тестов, регистровый слой (register layer) для моделирования регистров и др.

* **Итог:**  UVM стала стандартом де-факто для верификации аппаратного обеспечения.  Она значительно упрощает создание, отладку и поддержку тестовых окружений, повышает повторное использование кода и улучшает взаимодействие между разработчиками.  Переход от ad-hoc подходов и OVM к UVM стал важным шагом в развитии методологий верификации.

### Преимущества UVM
- Использование единого стиля разработки для всех верификационных проектов.
- Переиспользуемость компонентов, написанных ранее.
- Возможность делегирования выполняемых работ по созданию тестового окружения и непосредственно самих тестов.
- Уменьшение времени, затраченного на написание элементов синхронизации между разными компонентами окружения.
- Множество компаний используют UVM, как основную методологию для верификации проектов. Методология поддерживается и постоянно развивается. (На данный момент последняя ревизия библиотеки UVM 2020-1.1)